[
  {
    "objectID": "scratch.html",
    "href": "scratch.html",
    "title": "Non-FVS variables",
    "section": "",
    "text": "library(tidyverse)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\nstandlist &lt;- read_csv(\"C:/RxFire/Regen/Regen_Notes/standlist03242024.csv\", \n                      col_types = c(\"cccc\")) \n\nn_distinct(standlist$STAND_CN)\n\n[1] 7257\n\nSTAND_CN &lt;- NULL\nSTAND_CN &lt;- str_c(\"'\", unique(standlist$STAND_CN), \"'\")\nSTAND_CN &lt;- str_flatten_comma(STAND_CN)\n\n# COND::BALIVE Basal area per acre of livetrees\nsubcond &lt;- dbGetQuery(con, str_c(\n  \"select * from subp_cond where PLT_CN IN (\", STAND_CN, \")\"))\ncond &lt;- dbGetQuery(con, str_c(\n  \"select * from cond where PLT_CN IN (\", STAND_CN, \")\"))\n\n# P2VEG_STR::COVER_PCT, NT AND TT ARE TREES. \nveg &lt;- dbGetQuery(con, str_c(\n  \"select * from P2VEG_SUBP_STRUCTURE where PLT_CN IN (\", STAND_CN, \")\"))\n\ntree &lt;- dbGetQuery(con, str_c(\n  \"select * from FVS_TREEINIT_PLOT where STAND_CN IN (\", STAND_CN, \")\"))\n\nsubcond &lt;- subcond |&gt; \n  mutate(\n    STANDPLOT_CN = str_c(as.character(PLT_CN), \"_\", as.character(SUBP))\n  )\ns &lt;- subcond |&gt; select(PLT_CN, STANDPLOT_CN, SUBP, CONDID, )\n\nc &lt;- left_join(s, cond, join_by(PLT_CN, CONDID))\nc2 &lt;- c |&gt; select(STANDPLOT_CN, BALIVE) |&gt; drop_na()\n\nveg &lt;- veg |&gt; \n  mutate(\n    STANDPLOT_CN = str_c(as.character(PLT_CN), \"_\", as.character(SUBP))\n  )\n\n\nv &lt;- veg |&gt; filter(LAYER == 5)\nv &lt;- v |&gt; filter(GROWTH_HABIT_CD == \"TT\")\n\nv2 &lt;- v |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarise(CC = sum(COVER_PCT))\n\np. 183 FVS essentials.\n\\[\nSDI = \\sum (TPA_i (\\frac{DBH}{10})^{1.605})\n\\] TPA_i is tpa for a tree record.\nSDI is the sum of Trees per acre times the DBH for those trees, divided by ten to the power of 1.605.\nDBH and tpa are in the tree table.\n\nx &lt;- standlist |&gt; select(STANDPLOT_CN)\n\nt &lt;- left_join(x, tree, by = \"STANDPLOT_CN\")\nc &lt;- left_join(x, cond, by = \"STANDPLOT_CN\")\nv &lt;- left_join(x, veg, by = \"STANDPLOT_CN\")\n\ntpa &lt;- t |&gt; \n  mutate(sdi = (TREE_COUNT * ((DIAMETER/10)^1.605)))\n\nsdi &lt;- tpa[tpa$HISTORY == 1, ] |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarize(SDI = sum(sdi)) |&gt; drop_na()\n\n\ny &lt;- left_join(x, sdi, by = \"STANDPLOT_CN\")\n\ny &lt;- left_join(y, c2, by = \"STANDPLOT_CN\")\n\ny &lt;- left_join(y, v2, by = \"STANDPLOT_CN\")\n\nCanopy cover is not well predicted by the p2veg tables."
  },
  {
    "objectID": "1_Copied_Code.html",
    "href": "1_Copied_Code.html",
    "title": "Plot Selection",
    "section": "",
    "text": "The following code is pulled from my last set of notes in the stated chapters. It has all been updated as of Mar 23 2024.\nTo do\nThe code on this page goes from a shapefile and FIA data to FVS’s computed variables. ___"
  },
  {
    "objectID": "1_Copied_Code.html#plot-selection",
    "href": "1_Copied_Code.html#plot-selection",
    "title": "Plot Selection",
    "section": "Plot selection",
    "text": "Plot selection\n\nlibrary(tidyverse)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\nPrevious steps:\n\nI pulled the lat and long from the FIA’s WA database.\nCreated a point cloud from the coordinates table in Arc Pro.\nClipped the point cloud with POC3/OKWEN/OKWEN_shapefiles/OKWEN_AllFOAs_60km_buffer.shp\nSaved the clipped points to 60k_buffer_fiaplots.csv.\n\nIn the following code:\n\nConnect to the WA FIA .db\nSummarize the eco regions present in the foa boundary.\nlist the eco regions in the study area.\nextract all eco regions in WA that are in our study area and the FVS_Ready data.\n\n\n\nCode\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# This is the selection of plots by lat long from the okwen all foas 60k buffer. \nfoa_60_plots &lt;- read.csv(\"C:/RxFire/Regen/60k_buffer_fiaPlots.csv\")\n\n# Matching the foa cns to the table with ecoregions. \ncns &lt;- foa_60_plots |&gt; select(CN)\n\n# dbListTables(con)\n# dbListFields(con, \"FVS_PLOTINIT_PLOT\")\n\nplots &lt;- dbGetQuery(con, \"SELECT STAND_CN, STANDPLOT_CN, ECOREGION FROM FVS_PLOTINIT_PLOT\")\n\ncns$CN &lt;- as.character(cns$CN)\n\n# 45304 plots\nplots_60 &lt;- left_join(cns, plots, join_by(CN == STAND_CN))\n\n# Checking the number of NAs\nprint(\"There are this many NAs\")\n\n\n[1] \"There are this many NAs\"\n\n\nCode\nnrow(plots_60) - nrow(drop_na(plots_60))\n\n\n[1] 1436\n\n\nCode\nplots_60 &lt;- drop_na(plots_60)\n\ndbDisconnect(con)\n\n\nn_ecos &lt;- plots_60 |&gt; group_by(ECOREGION) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(desc(n))\n\n# Create a list of ecoregions in the study area. \n# The first time, I used gen_eco, that was too broad. \neco_list &lt;- n_ecos |&gt; \n  mutate(\n    gen_eco = str_sub(ECOREGION, 1, -2)\n  )\n# Pull all plots in those ecoregions. \n# nsa_plots &lt;- plots |&gt; mutate(\n#   gen_eco = str_sub(ECOREGION, 1, -2)) |&gt; \n#   filter(gen_eco %in% eco_list$gen_eco)\n\nnsa_plots &lt;- plots |&gt; mutate(\n  gen_eco = str_sub(ECOREGION, 1, -2)) |&gt; \n  filter(ECOREGION %in% eco_list$ECOREGION)\n\n# 59,800 plots w/gen_eco, 58878 w/ecoregion\n# save(nsa_plots, file = \"nsa_plots.Rdata\")\n\nrm(list = ls()[!ls() %in% c(\"nsa_plots\")])"
  },
  {
    "objectID": "1_Copied_Code.html#ch4",
    "href": "1_Copied_Code.html#ch4",
    "title": "Plot Selection",
    "section": "Ch4",
    "text": "Ch4\n\nlibrary(tidyverse, warn.conflicts = F)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\n# nsa_plots &lt;- read_csv(\"C:/RxFire/Regen/Species_Plot_ecotype/FIA_NSA_Nat_design_NEWWA.csv\",\n#                       col_types = c(\"c\"))\n\nload(\"./nsa_plots.Rdata\")\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# Making a list to pull from the big database'\n# This requires less RAM than loading in the database. \nstandlist &lt;- NULL\nstandlist &lt;- str_c(\"'\", nsa_plots$STAND_CN, \"'\")\nstandlist &lt;- str_flatten_comma(standlist)\n\n# Pulling the tables\nztree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE PLT_CN IN (\", standlist, \")\"))\nzplot &lt;- dbGetQuery(con, str_c(\"select * from plot WHERE CN IN (\", standlist, \")\"))\nzp2veg &lt;- dbGetQuery(con, str_c(\"select * from P2VEG_SUBPLOT_SPP WHERE PLT_CN IN (\", standlist, \")\"))\nSPGRPkey &lt;- dbGetQuery(con,\"select * from REF_SPECIES_GROUP\")\n\n\n# Removing empty fields\nzplot &lt;- zplot[, colSums(is.na(zplot)) &lt; nrow(zplot)]\n# zstand &lt;- zstand[, colSums(is.na(zstand)) &lt; nrow(zstand)]\nztree &lt;- ztree[, colSums(is.na(ztree)) &lt; nrow(ztree)]\n# ztree_init &lt;- ztree_init[, colSums(is.na(ztree_init)) &lt; nrow(ztree_init)] \nzp2veg &lt;- zp2veg[, colSums(is.na(zp2veg)) &lt; nrow(zp2veg)]\n\nzcond &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE PLT_CN IN (\", standlist, \")\"))\nzcond &lt;- zcond[, colSums(is.na(zcond)) &lt; nrow(zcond)]\n\nprint(\"the number of condition CNs in the standlist:\") \n\n[1] \"the number of condition CNs in the standlist:\"\n\ndim(zcond)\n\n[1] 19599    98\n\n# Remove artificial regeneration, keep NAs and zeros. \nzcond &lt;- zcond |&gt; filter(\n  STDORGCD == 0 | is.na(STDORGCD)\n)\nprint(\"after controlling for artificial regen\")\n\n[1] \"after controlling for artificial regen\"\n\ndim(zcond)\n\n[1] 18049    98\n\n# # Altered: remove all non-forest conditions. \n# Remove Non-Forested Conditions related to man. \n# unique(zcond$PRESNFCD)\nzcond &lt;- zcond |&gt; filter(\n  (is.na(PRESNFCD))\n)\nprint(\"after controlling for non-forest conditions\")\n\n[1] \"after controlling for non-forest conditions\"\n\ndim(zcond)\n\n[1] 11377    98\n\n# Remove unsampled plots and water\nzcond &lt;- zcond |&gt; filter(\n  COND_STATUS_CD == 1 | is.na(COND_STATUS_CD) | COND_STATUS_CD == 2\n)\n\n\n\n# Remove unsampled plots. \nzcond &lt;- zcond |&gt; filter(\n  is.na(COND_NONSAMPLE_REASN_CD)\n)\nprint(\"after controlling for unsampled and water\")\n\n[1] \"after controlling for unsampled and water\"\n\ndim(zcond)\n\n[1] 9880   98\n\n# There should also be a line for removing the periodic visits, \n# KINDCD = 0.\nzplot &lt;- zplot |&gt; filter(\n  KINDCD != 0\n)\nx &lt;- zplot |&gt; select(PLT_CN = CN, KINDCD)\ny &lt;- left_join(zcond, x, by = \"PLT_CN\")\nzcond &lt;- drop_na(y, KINDCD)\n\nprint(\"after controlling for periodic visits\")\n\n[1] \"after controlling for periodic visits\"\n\ndim(zcond)\n\n[1] 9145   99\n\nzcond &lt;- zcond |&gt; select(\n  CN, PLT_CN, CONDID, HABTYPCD = HABTYPCD1)\n\nzcond &lt;- zcond |&gt; mutate(\n  FPAG = str_remove_all(str_sub(HABTYPCD, 1, 4), \" \")\n)\n\n# NAs in FPAG\nna &lt;- zcond |&gt; filter(is.na(FPAG))\n# good needs some cleaning\ngood &lt;- zcond |&gt; filter(!is.na(FPAG))\n\ngood$PLT_CN &lt;- as.character(good$PLT_CN)\n\n# # Confirming there are no periodic plots. \n# good |&gt; group_by(PLT_CN) |&gt; \n#   summarise(len = str_width(PLT_CN)) |&gt; \n#   arrange(len)\n\n\n\nplants &lt;- read_csv(\"C:/RxFire/Regen/Species_Plot_ecotype/PLANTS.csv\",\n                   col_types = c(\"c\",\"c\",\"c\",\"c\",\"c\"))\n\nplants &lt;- plants |&gt; select(Symbol , Common_Name) |&gt; drop_na()\n# Join the Common Names to the veg list for readability\nzp2veg &lt;- left_join(zp2veg, plants, join_by(\"VEG_SPCD\" == \"Symbol\"))\n\n# Remove extra fields\nzp2veg &lt;- zp2veg |&gt; select(CN,\n  PLT_CN, VEG_SPCD, Common_Name, COVER_PCT, PLOT, SUBP, VEG_FLDSPCD, \n  UNIQUE_SP_NBR, GROWTH_HABIT_CD)\n\n\ntest &lt;- na |&gt; select(CN)\n\n\n# Looking at those NAs\nCN &lt;- NULL\nCN &lt;- str_c(\"'\", test$CN, \"'\")\nCN &lt;- str_flatten_comma(CN)\n\ntest2 &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE CN IN (\", CN, \")\"))\ntest2 &lt;- test2[, colSums(is.na(test2)) &lt; nrow(test2)]\n\ntest &lt;- test2 |&gt; select(CN, PLT_CN)\nPLT_CN &lt;- NULL\nPLT_CN &lt;- str_c(\"'\", test$PLT_CN, \"'\")\nPLT_CN &lt;- str_flatten_comma(PLT_CN)\n\n# all cns that didn't have FPAGs\ntcond &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE CN IN (\", CN, \")\"))\n\n# These plots exist and have trees, but these cond.CN's do not. \n\n# ttree has zero tree records, but tttree does. The stands have trees but not on \n#  those conditions. \nttree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE CN IN (\", CN, \")\"))\ntttree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE PLT_CN IN (\", PLT_CN, \")\"))\n\n# There are 1,319 cond's on 1,268 plots. \n# second time through, there are 276 tconds and 245 tplots. \ntplot &lt;- dbGetQuery(con, str_c(\"select * from plot WHERE CN IN (\", PLT_CN, \")\"))\n\n\nrm(CN, PLT_CN, test, test2, tcond, ttree, tttree, tplot)\nrm(ztree, zplot, zp2veg, zcond, plants, nsa_plots, na)\nrm(standlist)\n\ndbDisconnect(con)\n\ng &lt;- good |&gt; select(PLT_CN, CONDID, HABTYPCD) |&gt; unique()\n\n# write_csv(good, \"./good_plots_03242024.csv\")\n\n6092 stands to use vs 6,337 before."
  },
  {
    "objectID": "1_Copied_Code.html#ch-5",
    "href": "1_Copied_Code.html#ch-5",
    "title": "Plot Selection",
    "section": "CH 5",
    "text": "CH 5\ngood shouldn’t have the short cns. Those are periodic visits.\n\nrm(list = ls())\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# This is just the csv I saved above. \ngood &lt;- read_csv(\"./good_plots_03242024.csv\",\n                 col_types = c(\"ccnc\"))\n\ngood &lt;- good |&gt; select(PLT_CN, CONDID, FPAG) |&gt; unique()\ng &lt;- good |&gt; select(PLT_CN) |&gt; unique()\n\nPLT_CN &lt;- NULL\nPLT_CN &lt;- str_c(\"'\", g$PLT_CN, \"'\")\nPLT_CN &lt;- str_flatten_comma(PLT_CN)\n\nzsubplot &lt;- dbGetQuery(con, str_c(\"select * from subplot WHERE PLT_CN IN (\", PLT_CN, \")\"))\nzsubcond &lt;- dbGetQuery(con, str_c(\"select * from subp_cond WHERE PLT_CN IN (\", PLT_CN, \")\"))\n\n\n# This is every plot and condition that we could sample. \nzsubcond &lt;- left_join(good, zsubcond, join_by(PLT_CN, CONDID))\n\nzsubplot &lt;- zsubplot[, colSums(is.na(zsubplot)) &lt; nrow(zsubplot)]\nzsubcond &lt;- zsubcond[, colSums(is.na(zsubcond)) &lt; nrow(zsubcond)]\n\n# filter for where micro and sup were the same\nzsubplot &lt;- zsubplot |&gt; filter(\n  (MICRCOND == SUBPCOND)\n)\n\n# select all plots with equal conditions and some data for fpag\nzsubkey &lt;- zsubplot |&gt; select(PLT_CN, SUBP) |&gt; unique()\nzcondkey &lt;- zsubcond |&gt; select(PLT_CN, SUBP, FPAG) |&gt; unique()\n#  drop_na()\n\n# Joing them to make a key\nzcon &lt;- left_join(zsubkey, zcondkey, join_by(PLT_CN, SUBP)) |&gt; drop_na()\n\nzsubcond &lt;- zsubcond |&gt; select(\n  PLT_CN, CONDID, FPAG, CN, INVYR, PLOT, SUBP, MICRCOND_PROP, SUBPCOND_PROP, \n  MACRCOND_PROP, NONFR_INCL_PCT_SUBP, NONFR_INCL_PCT_MACRO, CYCLE)\n\n\nunique_conds &lt;- zsubcond |&gt; \n  filter(\n    near(SUBPCOND_PROP, 1, tol = .025) & near(MICRCOND_PROP, 1, tol = .025)\n    )\n\nt &lt;- unique_conds |&gt; select(PLT_CN, SUBP, CN, FPAG)\n\nt &lt;- t |&gt; filter(\n  !startsWith(FPAG, \"A\") & !startsWith(FPAG, \"N\") & !startsWith(FPAG, \"W\")\n)\n\n# I chose CAS4 bc it was the largest group of the three options. \nt &lt;- t |&gt; mutate(\n  FPAG = ifelse(FPAG == \"PIAL\", \"CAGO\", FPAG)\n)\n\nsubs &lt;- t |&gt; rename(SUBPLOT_CN = CN)\n\nunique(t$FPAG) |&gt; sort()\n\n  [1] \"CA\"   \"CAC1\" \"CAC5\" \"CACE\" \"CAF2\" \"CAF3\" \"CAG1\" \"CAG2\" \"CAG3\" \"CAGO\"\n [11] \"CAS-\" \"CAS2\" \"CAS3\" \"CAS4\" \"CC\"   \"CCF2\" \"CCHS\" \"CCS2\" \"CCS3\" \"CD\"  \n [21] \"CD27\" \"CD61\" \"CD63\" \"CD81\" \"CDF0\" \"CDF4\" \"CDG1\" \"CDG2\" \"CDG3\" \"CDG6\"\n [31] \"CDGE\" \"CDH4\" \"CDRX\" \"CDS\"  \"CDS1\" \"CDS2\" \"CDS3\" \"CDS4\" \"CDS5\" \"CDS6\"\n [41] \"cds7\" \"CDS7\" \"CDS8\" \"CE\"   \"CE41\" \"CE54\" \"CEF1\" \"CEF2\" \"CEF3\" \"CEF4\"\n [51] \"CEFA\" \"CEFH\" \"CEFM\" \"CEG1\" \"CEG2\" \"CEG3\" \"CEM1\" \"CEM2\" \"CEM3\" \"CEN2\"\n [61] \"CERR\" \"CES\"  \"CES1\" \"CES2\" \"CES3\" \"CES4\" \"CES5\" \"CES6\" \"CF\"   \"CFF1\"\n [71] \"CFF2\" \"CFF3\" \"CFF4\" \"CFM1\" \"CFRR\" \"CFS\"  \"CFS-\" \"CFS1\" \"CFS2\" \"CFS3\"\n [81] \"CFS4\" \"CFS5\" \"CFS6\" \"CFSC\" \"CH\"   \"CH12\" \"CH21\" \"CH6-\" \"CH62\" \"CHC2\"\n [91] \"CHD1\" \"CHF\"  \"CHF0\" \"CHF1\" \"CHF2\" \"CHF3\" \"CHF4\" \"CHF5\" \"CHF6\" \"CHF9\"\n[101] \"CHFI\" \"CHFS\" \"CHM1\" \"CHMI\" \"CHS\"  \"CHS1\" \"CHS2\" \"CHS3\" \"CHS4\" \"chs5\"\n[111] \"CHS5\" \"CHS6\" \"CHS7\" \"CHS8\" \"CHS9\" \"CHSI\" \"CL\"   \"CLM4\" \"CLS2\" \"CLS3\"\n[121] \"CLS4\" \"CLS5\" \"CM\"   \"CM53\" \"CM55\" \"CMF1\" \"CMF2\" \"CMG2\" \"CMS1\" \"CMS2\"\n[131] \"CMS3\" \"CMS4\" \"CMS5\" \"CP\"   \"CPF0\" \"CPG0\" \"CPG1\" \"CPG2\" \"CPS0\" \"CPS2\"\n[141] \"CPS3\" \"CPS5\" \"CS\"   \"CS53\" \"CSF1\" \"CSF2\" \"CSF3\" \"CW\"   \"CW33\" \"CW55\"\n[151] \"CW61\" \"CWC4\" \"CWF0\" \"CWF2\" \"CWF3\" \"CWF4\" \"CWF5\" \"CWG1\" \"CWGI\" \"CWS2\"\n[161] \"CWS3\" \"CWS4\" \"CWS5\" \"CWS8\" \"HA\"   \"HAF\"  \"HAM0\" \"HAM1\" \"HAS1\" \"HAS3\"\n[171] \"HB\"   \"HBM1\" \"HBS1\" \"HC\"   \"HCD1\" \"HCS1\" \"HCS3\" \"HD\"   \"HM\"   \"HO\"  \n[181] \"HOC2\" \"HOG1\" \"HOG2\" \"HOG3\" \"HOS1\" \"HOS3\" \"HOS6\" \"HQ\"   \"HQG1\" \"HQM2\"\n[191] \"HQS0\" \"HQS2\" \"HX\"   \"SM20\" \"SM40\" \"SM81\" \"SW21\" \"SW22\" \"SW72\"\n\ndbDisconnect(con)\n\nOnly conifer hardwood and shrub classes present.\n\nFVS prep\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# write_csv(subs, \"./good_SUB_plots.csv\")\n\nsubs &lt;- read_csv(\"./good_SUB_plots.csv\",\n                 col_types = c(\"cncc\"))\n\nsubs &lt;- subs |&gt; mutate(\n  STANDPLOT_CN = str_c(PLT_CN, \"_\", SUBP)\n)\n\nSTAND_CN &lt;- NULL\nSTAND_CN &lt;- str_c(\"'\", subs$PLT_CN, \"'\")\nSTAND_CN &lt;- str_flatten_comma(STAND_CN)\n\nSTANDPLOT_CN &lt;- NULL\nSTANDPLOT_CN &lt;- str_c(\"'\", subs$STANDPLOT_CN, \"'\")\nSTANDPLOT_CN &lt;- str_flatten_comma(STANDPLOT_CN)\n\n\nstand &lt;- dbGetQuery(con, \n                    str_c(\"Select * from FVS_STANDINIT_PLOT where STAND_CN IN (\", STAND_CN, \")\"))\n\nplot &lt;- dbGetQuery(con, \n                   str_c(\"Select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN IN (\", STANDPLOT_CN, \")\"))\n\nplot &lt;- plot[, colSums(is.na(plot)) &lt; nrow(plot)]\nstand &lt;- stand[, colSums(is.na(stand)) &lt; nrow(stand)]\n\nplot &lt;- subset(plot, select = -c(GROUPS, INV_MONTH, INV_DAY, DATUM))\n\n\nstand &lt;- subset(stand, select = -c(INV_MONTH, INV_DAY, STATE, COUNTY))\n\n\nt &lt;- plot |&gt; select(STANDPLOT_CN)\n\nt &lt;- left_join(t, subs, by = \"STANDPLOT_CN\")\n\nt &lt;- t |&gt; mutate(\n  FPAG = str_remove_all(str_to_upper(FPAG), \" \")\n)\n\nSTANDPLOT_CN &lt;- NULL\nSTANDPLOT_CN &lt;- str_c(\"'\", t$STANDPLOT_CN, \"'\")\nSTANDPLOT_CN &lt;- str_flatten_comma(STANDPLOT_CN)\n\ntree &lt;- dbGetQuery(con, \n                   str_c(\"Select * from FVS_TREEINIT_PLOT where STANDPLOT_CN IN (\", STANDPLOT_CN, \")\"))\n\ntree &lt;- tree[, colSums(is.na(tree)) &lt; nrow(tree)]\n\n\n# 8701 records\nregen &lt;- tree |&gt; filter(\n  startsWith(TREE_CN, \"S\")\n) |&gt; select(STANDPLOT_CN) |&gt; unique()\n\n\nsubs &lt;- subs[, c(1, 2, 4, 5)]\n\nregen &lt;- left_join(regen, subs, by = \"STANDPLOT_CN\")\n\nrtrees &lt;- left_join(regen, tree, by = \"STANDPLOT_CN\")\n\nt4 &lt;- regen |&gt; group_by(FPAG) |&gt; summarise(n = n()) \n\nprint(\"Median number of subplots where regen occurred is \")\n\n[1] \"Median number of subplots where regen occurred is \"\n\nmedian(t4$n)\n\n[1] 8\n\ns &lt;- subs |&gt; select(STANDPLOT_CN, FPAG)\np &lt;- left_join(plot, s, by = \"STANDPLOT_CN\")\n\np$INV_YEAR &lt;-  2020\n\n\nrm(t, t4)\ndbDisconnect(con)\n\nname &lt;- str_c(\"FVS_inputDB_\", \n              strftime(Sys.Date(),\"%m%d%y\"), \n              \"_\", \n              strftime(Sys.time(),\"%H%M\"),\n              \".db\")\n\n# con = dbConnect(RSQLite::SQLite(), dbname = str_c(\"../\", name)\n# \n# dbWriteTable(conn = con, name = \"FVS_STANDINIT_PLOT\", value = stand, overwrite = T)\n# dbWriteTable(conn = con, name = \"FVS_PLOTINIT_PLOT\", value = p, overwrite = T)\n# dbWriteTable(conn = con, name = \"FVS_TREEINIT_PLOT\", value = tree, overwrite = T)\n# dbListTables(conn = con)\n# dbDisconnect(con)\n\nstandlist &lt;- p |&gt; select(STAND_CN, STANDPLOT_CN, VARIANT, FPAG)\n\nunique(standlist$VARIANT)\n\n[1] \"EC\" \"WC\" \"PN\" \"IE\"\n\nstandlist &lt;- standlist |&gt; mutate(\n  VARIANT = ifelse(VARIANT == \"PN\", \"WC\", VARIANT),\n  VARIANT = ifelse(VARIANT == \"IE\", \"EC\", VARIANT)\n)\nunique(standlist$VARIANT)\n\n[1] \"EC\" \"WC\"\n\nname &lt;- str_c(\"standlist_\", \n              strftime(Sys.Date(),\"%m%d%y\"), \n              \"_\", \n              strftime(Sys.time(),\"%H%M\"),\n              \".csv\")\n\n# write_csv(standlist, str_c(\"./\", name))"
  },
  {
    "objectID": "1_Copied_Code.html#ch-6-fvs",
    "href": "1_Copied_Code.html#ch-6-fvs",
    "title": "Plot Selection",
    "section": "CH 6 FVS",
    "text": "CH 6 FVS\nThis code chunk runs FVS to get CC, BA, and SDI.\nSet FVS bin to the FVS executable.\nThis time consuming step might be avoided using the p2veg_spp table. There is a canopy cover by species variable there. It could be summed. Also, perhaps using percent CC by species could be a better predictor than just CC.\nFVS has been running for 20 minutes with these 25,516 subplots.\n\nrm(list = ls())\n\nlibrary(RSQLite)\nlibrary(tidyverse, quietly = T, warn.conflicts = F)\nlibrary(readxl)\n\noptions(scipen = 999)\n\n\n# 1. Set paths ---------------------------------------------------------------\n## Set all the file paths and names in this section. Then, run the rest of the script in sections 2. \n\n## Set the working directory here.\n# setwd(\"C:\\\\RxFire\\\\Regen\\\\FVS\")\nfvs_wd &lt;- \"C:\\\\RxFire\\\\Regen\\\\FVS\"\n\n## Where are the FVS executables? FVSbin? \n#  Include the \\\\FVS prefix to variant.exe. \nFVSbin &lt;-  \"C:\\\\FVSbin_v3.1\\\\FVS\"\n\n# Test\n\nname &lt;- str_c(\"regen_\", \n              strftime(Sys.Date(),\"%m%d%y\"), \n              \"_\", \n              strftime(Sys.time(),\"%H%M\"))\n\n\n## Set the path to the stand input database here, aka the output db from 3_CNs_to_FVS:\ninputDatabase &lt;- 'C:/RxFire/Regen/Mar24_Regen_FVS.db'\n# C:\\\\RxFire\\\\Data\\\\FIADB_WA.db\n# C:\\\\RxFire\\\\Regen\\\\FVS\\\\Feb6_Regen_FVS_1.db\n# C:\\\\RxFire\\\\Regen\\\\Feb7_Regen_FVS_1.db\n\n# 1.2 Standlist from xlsx -------------------------------------------------\n\nstandlist &lt;- read_csv(\"C:/RxFire/Regen/Regen_Notes/standlist03242024.csv\", \n                      col_types = c(\"cccc\")) |&gt; select(\n                        CN = STANDPLOT_CN, FVSVariant = VARIANT\n                      ) \n\n# This is to speed up the testing\n# standlist &lt;- standlist[1:1000, ]\n\n\n\n# 2. Batch file Creation -----------------------------------------------------\n## Run everything in section 2. There shouldn't be anything to change.\n#  Except, maybe createInputFile(group_stands$CN[s], if CN was read in as Stand_CN. \n\n\nint &lt;- Sys.time()\n\n# Create directory where FVS runs will be sent:\nRunDirectory &lt;- str_c(fvs_wd, '/', name)\n\nif (!dir.exists(RunDirectory)) {\n  print(paste(\"Making Run directory: \", RunDirectory))\n  dir.create(RunDirectory)\n} else(\n  print(str_c(RunDirectory, \", already exists\"))\n)\n\n# Create input Directory\ninputDirectory &lt;- str_c(RunDirectory, \"/In\")\n\nif (!dir.exists(inputDirectory)) {\n  print(paste(\"Making input directory: \", inputDirectory))\n  dir.create(inputDirectory)\n} else(\n  print(str_c(inputDirectory, \", already exists\"))\n)\n\n# Create Cmd Directory\nCmdDirectory &lt;- str_c(RunDirectory, \"/Cmd\")\n\nif (!dir.exists(CmdDirectory)) {\n  print(paste(\"Making input directory: \", CmdDirectory))\n  dir.create(CmdDirectory)\n} else(\n  print(str_c(CmdDirectory, \", already exists\"))\n)\n\n## The path to the FVS output database is set here:\noutputDatabase &lt;- str_c(RunDirectory, \"/\", name, \".db\")\n\n\n\n## This function creates the string for a single stand in FVS.\ncreateInputFile &lt;- function(stand, managementID, inputDatabase, outputDatabase){\n  # Create .key file\n  input &lt;- paste0('STDIDENT\\n',                     \n                  stand, '\\n',                     \n                  'STANDCN\\n',                     \n                  stand, '\\n',                     \n                  'MGMTID\\n',                     \n                  managementID,                     \n                  '\\n',                             \n                  'NUMCYCLE          1\\n', # Set time intervals. \n                  # 0 = Change all cycles | Cycle length to one year\n                  'TIMEINT           0         1\\n',\n                  'SCREEN\\n',               \n                  'DATABASE\\n',                                                                                     # Databases in    \n                  'DSNIN\\n',                                                \n                  inputDatabase, '\\n',                                        \n                  'StandSQL\\n',                                             \n                  'SELECT * FROM FVS_PLOTINIT_PLOT\\n',\n                  # 'SELECT * FROM FVS_PlotInit\\n',  # For a different table name                   \n                  \"WHERE  Standplot_CN  = '%stand_cn%'\\n\",                     \n                  'EndSQL\\n',                                                    \n                  'DSNIN\\n',                                          \n                  inputDatabase, '\\n',                                             \n                  'TreeSQL\\n',\n                  'SELECT * FROM FVS_TREEINIT_PLOT\\n',\n                  # 'SELECT * FROM FVS_TreeInit\\n',                              \n                  \"WHERE  Standplot_CN  = '%stand_cn%'\\n\",                            \n                  'EndSQL\\n',                                                          \n                  'END\\n',   # Database ends here\n                  'STRCLASS\\n',\n                  # year of compute 0 = Every cycle\n                  'COMPUTE           0\\n',                                                                        # Compute below here\n                  # # acancov defined when str_class is used, after thin Canopy\n                  'CC = bcancov\\n',\n                  'END\\n',                                                                                            # Compute ends\n                  'DATABASE\\n',                                                                                     # DB Out Starts\n                  'DSNOUT\\n',                                      \n                  outputDatabase, '\\n',\n                  'SUMMARY           2\\n',\n                  'StrClsDB\\n',\n                  'COMPUTDB\\n',\n                  'END\\n',\n                  'Process\\n\\n')                                    \n                   \n  \n}\n\nwrite(str_c(\"set RScript=\", \" \\\"\", \"C:/Program Files/R/R-4.3.1/bin/Rscript.exe\", \"\\\"\",\n            \"\\n \\n\",\n            \"cd \", inputDirectory, \"\\n\\n\"), paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n\n\n\nfor (g in unique(standlist$FVSVariant)) {\n  masterkeys &lt;- NULL\n  group_stands &lt;- subset(standlist, FVSVariant == g)\n  for (s in 1:nrow(group_stands)) {\n    \n    keywords &lt;- createInputFile(stand = group_stands$CN[s], managementID = group_stands$CN[s], \n                                inputDatabase = inputDatabase,\n                                outputDatabase = outputDatabase\n                                )\n    \n    masterkeys &lt;- paste0(masterkeys, keywords)\n  }\n  # Print to the key file\n  masterkeys &lt;- paste0(masterkeys, \"\\nSTOP\\n\")\n  # \"\\n STOP?\\n\" or \"\\nSTOP\\n\", outfile has errors 1 & 2, invalid keyword & no Stop\n  file_name &lt;- str_sub(g, end = -5)\n  write(masterkeys, file = str_c(inputDirectory, '\\\\', g, '.key'))\n  \n  ## Create the .in file ##\n  fvs_in &lt;- paste0(g, \".key\\n\",\n                   g, \".fvs\\n\",\n                   g, \".out\\n\",\n                   g, \".trl\\n\",\n                   g, \".sum\\n\")\n  \n  fvs_in_file &lt;- paste0(inputDirectory, '\\\\', g, '.in')\n  write(fvs_in, file = fvs_in_file)\n  fvs_bat &lt;- paste0(FVSbin, unique(group_stands$FVSVariant), \".exe &lt; \", g, \".in &gt;\",\n                    RunDirectory, \"/Cmd/\", g, \".txt\", \" 2&gt;&1\", \"\\n\",\n                    # Send each CMD file to this script\n                    \"%RScript%\",\" C:/RxFire/Scripts/ErrorProcessing/RcmdProcess.R \",\n                    \"\\\"\", RunDirectory, \"/Cmd/\", g, \".txt\", \"\\\"\", \"\\n\")\n  \n  write(fvs_bat, paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n}\n\n# Summarize the OUT files\nfvs_errors &lt;- str_c(\"\\nREM This one cleans in extra files out and summarizes the output the Run Directory \\n\",\n                    \"%RScript%\",\" C:/RxFire/Scripts/ErrorProcessing/RfvsProcess.R \",\n                    \"\\\"\", RunDirectory, \"/In\", \"\\\"\")\n\nwrite(fvs_errors, paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n\n# write(\"PAUSE\", paste0(inputDirectory, '\\\\test.bat'), append = \"TRUE\")\n\nout &lt;- Sys.time()\n\nprint(out - int)\n\n# Run this Batch file\nshell.exec(str_c(RunDirectory, '\\\\test.bat'))"
  },
  {
    "objectID": "1_Copied_Code.html#imputation-prep",
    "href": "1_Copied_Code.html#imputation-prep",
    "title": "Plot Selection",
    "section": "Imputation Prep",
    "text": "Imputation Prep\nPull the FVS output and organize the data.\n\nlibrary(tidyverse, quietly = T)\nlibrary(esquisse)\nlibrary(yaImpute)\nlibrary(RSQLite)\nlibrary(vegan)\nlibrary(randomForest)\nlibrary(RSQLite)\n\noptions(scipen = 999)\n\nSet k for knn. Get the compute and summary tables from the fvs run. Get the tree and plots tables from fvs_ready. Also adding the cond table for troubleshooting.\n\nk = 10\n\n\n# Pulling my list of subplots with FPAGs that I used in FVS\n# \"C:\\RxFire\\Regen\\Regen_Notes\\standlist03242024.csv\"\n# getwd()\nstandlist &lt;- read_csv(\"standlist03242024.csv\", \n                      col_types = c(\"cccc\")) \n\n\n## The FVS variables DB I created earlier by running these plots in FVS\n## and extracting the first years estimates of CC, BA, & SDI\n# \"C:/RxFire/Regen/FVS/regen_020724_4n/regen_020724_4n.db\"\n# \"C:\\RxFire\\Regen\\FVS\\regen_032524_0919\\regen_032524_0919.db\"\ncon &lt;- dbConnect(\n  RSQLite::SQLite(), \"C:/RxFire/Regen/FVS/regen_032524_0919/regen_032524_0919.db\"\n  )\n\n# Compute has CC\n# Summary2 has BA and SDI\ncomp &lt;- dbGetQuery(con, \"select CaseID, StandID, CC from FVS_Compute\")\nsummary &lt;- dbGetQuery(\n  con, \n  str_c(\"select CaseID, StandID, Tpa, BA, SDI from FVS_Summary2\",\n        \" where Year = 2020\")\n  )\n\npred &lt;- left_join(comp, summary, join_by(CaseID, StandID))\n\ndbDisconnect(con)\n\n# rm(comp, summary, con)\n\n# making a list for sql\ndb_list &lt;- function(df, CN_col){\n  name &lt;- NULL\n  name &lt;- df |&gt; select({{CN_col}})\n  name &lt;- name |&gt; mutate(CN_col = str_c(\"'\", {{CN_col}}, \"'\")) \n  name &lt;- str_flatten_comma(name$CN_col)\n  # name &lt;- str_flatten_comma(name[, CN_col])\n  name\n}\nstplt_cn &lt;- db_list(df = pred, CN_col = StandID)\n\n\n# connecting to the WA state FIA db\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# collecting the trees\ntree &lt;- dbGetQuery(\n  con, \n  str_c(\"select * from FVS_TREEINIT_PLOT where STANDPLOT_CN in (\", \n        stplt_cn, \")\"))\n\n# collecting tne plots and subplots\nplot &lt;- dbGetQuery(\n  con, \n  str_c(\"select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN in (\", \n        stplt_cn, \")\"))\n\n\n# cond &lt;- dbGetQuery(\n#   con, \n#   str_c(\"select * from cond where STANDPLOT_CN in (\", \n#         stplt_cn, \")\"))\n\ndbDisconnect(con)\n\nClean the tables.\n\n# Cleaning out the NA columns\nclean_na_cols &lt;- function(df){\n  df &lt;- df[, colSums(is.na(df)) &lt; nrow(df)]\n}\n\ntree &lt;- clean_na_cols(tree)\nplot &lt;- clean_na_cols(plot)\n\n# Cleaning out the useless columns\nplot &lt;- plot |&gt; select(-c(GROUPS, STAND_ID, STANDPLOT_ID, INV_DAY, INV_MONTH, \n                          REGION, FOREST, SAM_WT, PHYSIO_REGION, STATE, COUNTY))\n\ntree &lt;- tree |&gt; select(-c(STAND_ID, STANDPLOT_ID))\n\npred &lt;- pred |&gt; select(-c(CaseID, Tpa))\n\nSeedling densities are the trees per acre for each species’ seedlings. Adding the plant symbols for seedlings.\n\n# Separating the seedlings from the rest\nseedling_densities &lt;- tree |&gt;  filter(startsWith(TREE_CN, \"S\")) |&gt; \n  group_by(STANDPLOT_CN, SPECIES) |&gt; \n  summarise(TPA = sum(TREE_COUNT))\n\n`summarise()` has grouped output by 'STANDPLOT_CN'. You can override using the\n`.groups` argument.\n\ncon &lt;- dbConnect(\n  RSQLite::SQLite(), \"C:\\\\RxFire\\\\Data\\\\_FIADB_WA.db\"\n  )\n# Pulling in the species reference table\nplants_ref &lt;- dbGetQuery(\n  con, \"select SPECIES_SYMBOL, SPCD, COMMON_NAME, W_SPGRPCD from REF_SPECIES\"\n  )\nplant_gr_ref &lt;- dbGetQuery(\n  con, \"select SPGRPCD, NAME from REF_SPECIES_GROUP\"\n  )\ndbDisconnect(con)\n\n# Cleaning it up\nplants_ref &lt;- plants_ref |&gt; rename(SPGRPCD = W_SPGRPCD, SYMBL = SPECIES_SYMBOL)\nplants_ref &lt;- left_join(plants_ref, plant_gr_ref, by = join_by(SPGRPCD))\nplants &lt;- plants_ref |&gt; select(SYMBL, SPCD)\nseedling_densities &lt;- seedling_densities |&gt; mutate(SPECIES = as.numeric(SPECIES))\n\n# Getting plant codes for seedlings\nseedling_densities &lt;- left_join(seedling_densities, plants, join_by(\"SPECIES\" == \"SPCD\"))\n# Removing an extra col. \nseedling_densities &lt;- seedling_densities |&gt; select(-c(SPECIES))\n\nWidening the table to match the st Joe example. The value of each species TPA goes into a column for that species. Each row is a standplot_cn. If there were no species of a type in that stand, a zero is entered.\n\n# Matching the St. Joe data\nseedling_response &lt;- seedling_densities |&gt; pivot_wider(names_from = SYMBL, \n                 values_from = TPA,\n                 values_fill = 0,\n                 names_glue = \"{SYMBL}_{'TD'}\")\n\n\n# Un-grouping to avoid future messages\nseedling_response &lt;- seedling_response |&gt; ungroup()\nseedling_densities &lt;- seedling_densities |&gt; ungroup()\n\n\n\n\n# replacing all NAs with zero, just in case\nnas_to_zeroes &lt;- function(df){\n  df &lt;- df |&gt; mutate_all(~replace(., is.na(.), 0))\n  df\n}\nseedling_response &lt;- nas_to_zeroes(seedling_response) \n\n# clearing out the objects\nX_predictors &lt;- NULL\nY_response &lt;- NULL\n# creating lists of subplots\nX_predictors &lt;- pred |&gt; select(STANDPLOT_CN = StandID) |&gt; unique()\nY_response &lt;- seedling_response |&gt; select(STANDPLOT_CN = STANDPLOT_CN)\n\nThere is a mismatch in dims between the predictors and response variables.\nX has about 25k rows and Y has about 13k. This is looking at all possible plots with the value computed from FVS, vs those plots with seedlings.\nIf I remove the extra 12k rows where no regeneration is occurring, that’s bad. If I don’t remove it, then I half of my data is zero.\nThe current plan is to use a couple models, one for probability of regeneration. one for regen with and one one without disturbance. From what I understand, the probability of regen model is for post disturbance. So, this is more of an ingrowth model. We need the zeroes and I don’t like that.\nThat is what I did last time, so at least the plots will be comparable.\nI think I can at least remove the subplots that are non-forested.\n\n# finding the mismatch \ntt &lt;- anti_join(X_predictors, Y_response, by = \"STANDPLOT_CN\")\n\nt &lt;- left_join(tt, tree, by = \"STANDPLOT_CN\")\n\nt2 &lt;- t |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarize(seedling_records = sum(startsWith(TREE_CN, \"s\")),\n            lt_records = sum(!startsWith(TREE_CN, \"s\")))\n\nt3 &lt;- t2 |&gt; filter(is.na(seedling_records) & is.na(lt_records)) |&gt; \n  select(STANDPLOT_CN)\n\n\nt2 &lt;- t2 |&gt; filter(!is.na(lt_records) & !is.na(seedling_records))\n\nOf those records where there is no regen, 12k at least had large trees. 1k had neither seedlings of large trees.\nI tried to find out why there were no trees on those subplots, but I couldn’t:\n# t3 &lt;- left_join(t3, plot, by = \"STANDPLOT_CN\")\n# \n# standlist &lt;- t3 |&gt; select(STAND_CN)\n# standcn &lt;- db_list(standlist, STAND_CN)\n# \n# con &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# \n# cond &lt;- dbGetQuery(\n#   con, \n#   str_c(\"select * from cond where PLT_CN in (\", \n#         standcn, \")\"))\n# \n# dbDisconnect(con)\n# \n# cond &lt;- clean_na_cols(cond)\n# \n# \n# cond_status_cd &lt;- cond |&gt; \n#   filter(COND_STATUS_CD == 1 | COND_STATUS_CD == 2 )\n# \n# # hist(cond_status_cd$OWNGRPCD)\n# \n# # Fire damage. \n# hist(cond_status_cd[cond_status_cd$DSTRBCD1 &gt; 29 & \n#                       cond_status_cd$DSTRBCD1 &lt; 40, \n#                     \"DSTRBCD1\"])\n# \n# cond_presnfcd &lt;- cond_status_cd |&gt; \n#   filter(is.na(PRESNFCD)) |&gt; clean_na_cols()\n# \n# cond_presnfcd &lt;- cond_presnfcd |&gt; \n#   select(-c(STATECD, INVYR, CN, COUNTYCD, PLOT,\n#             MAPDEN, PROP_BASIS, SLOPE, ASPECT, DSTRBYR1, DSTRBYR2, DSTRBYR3))\n# \n# # names(cond_presnfcd)\n# \n# cond_presnfcd &lt;- cond_presnfcd |&gt; \n#   select(-c(CREATED_BY, CREATED_DATE, CREATED_IN_INSTANCE, MODIFIED_BY, MODIFIED_DATE, MODIFIED_IN_INSTANCE))\n# \n# cond_presnfcd2 &lt;- cond_presnfcd[, c(1, 49:ncol(cond_presnfcd))]\n# \n# # summary(as.factor(cond_presnfcd$STUMP_CD_PNWRS))\n# \n# # hist(cond_presnfcd$BALIVE)\nThere are standplot_cns that do not have trees. I am not sure if I should count them. They might be NAs.\nLooking at an example:\n\nThe subplot table says they are all the same.\nThe Cond table doesn’t make distinctions for Subplots.\nThere are tree records in the the other three plots.\n\nI am not sure what to do. There are some codes that should be controlled for, but I cannot get rid of all of them. Some of the codes that should be controlled for were probably brought in with the cond table, I couldn’t use standplot_cn. So it pulled in every condition.\nI found this field and it could be of use:\nPHYSCLCD Physiographic class code. A code indicating the general effect of land form, topographical position, and soil on moisture available to trees.\n\nRemoving the no tree plots.\n\nx &lt;- anti_join(X_predictors, t3, by = \"STANDPLOT_CN\")\nnrow(X_predictors) - nrow(x)\n\n[1] 895\n\nX_predictors &lt;- left_join(x, X_predictors, by = \"STANDPLOT_CN\")\n\n\n# Adding the plots without regen. \nimp_response &lt;- left_join(X_predictors, seedling_response, join_by(STANDPLOT_CN))\n\n# removing the NAs\nimp_response &lt;- nas_to_zeroes(imp_response) \n# imp_data &lt;- imp_data[,1:35]\n\n# removing fields from standlist to join\nFPAG &lt;- standlist |&gt; select(STANDPLOT_CN, FPAG)\n# renaming the field\npred &lt;- pred |&gt; rename(STANDPLOT_CN = StandID)\n\npred &lt;- left_join(x, pred, by = \"STANDPLOT_CN\")\n# joining fpags to prediction list. \nimp_pred &lt;- left_join(pred, FPAG, by = \"STANDPLOT_CN\")\n\nimp_data &lt;- left_join(imp_pred, imp_response, by = \"STANDPLOT_CN\")\n\nMaking a set for the zeroes just in case.\n\nzx &lt;- Y_response |&gt; select(STANDPLOT_CN)\n# Adding the plots without regen. \nzimp_response &lt;- left_join(zx, seedling_response, join_by(STANDPLOT_CN))\n\n# removing the NAs\nzimp_response &lt;- nas_to_zeroes(zimp_response) \n\nzpred &lt;- left_join(zx, pred, by = \"STANDPLOT_CN\")\n# joining fpags to prediction list. \nzimp_pred &lt;- left_join(zpred, FPAG, by = \"STANDPLOT_CN\")\n\nzimp_data &lt;- left_join(zimp_pred, zimp_response, by = \"STANDPLOT_CN\")\n\nCleaning up the other tables\n\ntree &lt;- left_join(x, tree, by = \"STANDPLOT_CN\")\nplot &lt;- left_join(x, plot, by = \"STANDPLOT_CN\")\n\n\n# removing extra objects\nrm(con, X_predictors, Y_response, stplt_cn, t, plant_gr_ref, \n   plants, standlist, FPAG, pred)\n\n\nname &lt;- str_c(\"attempt_\", \n              strftime(Sys.Date(),\"%m%d%y\"))\n              # , \n              # \"_\"\n              # , \n              # strftime(Sys.Date(),\"%H%M\"))\n\n# con &lt;- dbConnect(RSQLite::SQLite(), str_c(\"./\", name, \".db\"))\n# dbWriteTable(con, \"imp_data\", imp_data)\n# dbWriteTable(con, \"plants_ref\", plants_ref)\n# dbWriteTable(con, \"FVS_PLOTINIT_PLOT\", plot)\n# dbWriteTable(con, \"FVS_TREEINIT_PLOT\", tree)\n# dbWriteTable(con, \"regen_only_imp_data\", zimp_data)\n# \n# dbDisconnect(con)\n\nkeep &lt;- c(\"clean_na_cols\", \"db_list\", \"nas_to_zeroes\", \"z_scores\", \"k\")\n# rm(list = ls()[!(ls() %in% keep)])"
  },
  {
    "objectID": "2_Imputation.html",
    "href": "2_Imputation.html",
    "title": "Imputation",
    "section": "",
    "text": "Pull the FVS output and organize the data.\nlibrary(tidyverse, quietly = T)\nlibrary(esquisse)\nlibrary(yaImpute)\nlibrary(RSQLite)\nlibrary(vegan)\nlibrary(randomForest)\nlibrary(RSQLite)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2_Imputation.html#first-set-of-code.",
    "href": "2_Imputation.html#first-set-of-code.",
    "title": "Imputation",
    "section": "First set of code.",
    "text": "First set of code.\nThis is a repeat of the first comparison I did. I am using the expanded dataset for this run, but for CDS6, it is only about 400 extra plots.\nThis time around, I saved a dataset where I only kept plots/stands that had regeneration/seedlings. So I changed it a little to compare three and six predictor variable models while also seeing what happens without so many zeroes.\n\n# Pulling from my new interim save point\ncon &lt;- dbConnect(RSQLite::SQLite(), \"./attempt_032524.db\")\nimp_data &lt;- dbGetQuery(con, \"select * from imp_data\")\nzimp_data &lt;- dbGetQuery(con, \"select * from regen_only_imp_data\")\nplots &lt;- dbGetQuery(con, \"select * from fvs_plotinit_plot\")\nplants_ref &lt;- dbGetQuery(con, \"select * from plants_ref\")\ndbDisconnect(con)\nrm(con)\n\npred_topo &lt;- plots |&gt; select(\n  STANDPLOT_CN, ELEVFT, SLOPE, ASPECT\n)\npred_Kral &lt;- imp_data |&gt; select(\n  STANDPLOT_CN, CC, BA, SDI, FPAG\n)\n\nresponse &lt;- imp_data |&gt; select(\n  -c(CC, BA, SDI, FPAG)\n)\n\npredictors &lt;- left_join(pred_Kral, pred_topo)|&gt; \n  relocate(FPAG, .after = STANDPLOT_CN)\n\n\n# Filtering for only CDS6\ncds6 &lt;- predictors |&gt; filter(\n  FPAG == \"CDS6\") |&gt; \n  select(-c(FPAG))\n\n\ncds_cns &lt;- cds6 |&gt; select(STANDPLOT_CN)\nzcds_cns &lt;- zimp_data |&gt; filter(FPAG == \"CDS6\") |&gt; select(STANDPLOT_CN)\nzcds6 &lt;- left_join(zcds_cns, cds6, by =\"STANDPLOT_CN\")\n\n# Joining the x and y\nimp_2 &lt;- left_join(cds_cns, response, by = \"STANDPLOT_CN\")\n# Making CN into rownames\nimp_2 &lt;- column_to_rownames(imp_2, \"STANDPLOT_CN\")\n# making sure it's not all zero\nimp_2 &lt;- imp_2[, !colSums(imp_2) == 0]\n\nimp_2 &lt;- left_join(cds6, response)\nzimp_2 &lt;- left_join(zcds6, response)\n\n\n# form some test data, y's are defined only for reference observations.\n# refs  =  sample(x  =  rownames(imp_2), size  =  (nrow(imp_2)/4)*3)\nrefs &lt;- rownames(imp_2[1:(round(.75*nrow(imp_2))), ])\n# zrefs  =  sample(x  =  rownames(zimp_2), size  =  (nrow(zimp_2)/4)*3)\nzrefs &lt;- rownames(zimp_2[1:(round(.75*nrow(zimp_2))), ])\n\n# x is every row and column of predictor variables.\n# CC, BA, SDI, ELEVFT, SLOPE, ASPECT\nX_predictors1 &lt;- imp_2 |&gt; select(CC, BA, SDI)\nX_predictors2 &lt;- imp_2 |&gt; select(CC, BA, SDI, ELEVFT, SLOPE, ASPECT)\nzX_predictors1 &lt;- zimp_2 |&gt; select(CC, BA, SDI)\nzX_predictors2 &lt;- zimp_2 |&gt; select(CC, BA, SDI, ELEVFT, SLOPE, ASPECT)\n\n# y is all other columns, seedling tree densities. \n# row names are row numbers\n# y &lt;- imp_df[refs,3:36], this was the example code. \nY_response &lt;- imp_2[refs,] |&gt; select(ends_with(\"TD\")) \nY_response &lt;- Y_response[, order(colSums(-Y_response))]\n\nzY_response &lt;- zimp_2[zrefs,] |&gt; select(ends_with(\"TD\")) \nzY_response &lt;- zY_response[, order(colSums(-zY_response))]\n\n# remove zero columns\nY_response &lt;- Y_response[, !colSums(Y_response) == 0]\nzY_response &lt;- zY_response[, !colSums(zY_response) == 0]\n\n\nk = 10\n\n# build yai objects using\n# most similar neighbor\nmsn_dist_3 &lt;- yai(x = X_predictors1, y = Y_response, method = \"msn\", k = k)\n# and mahalanobis\nmal_dist_3 &lt;- yai(x = X_predictors1, y = Y_response, method = \"mahalanobis\", k = k)\n\n# For the expanded list of predictors\nmsn_dist_6 &lt;- yai(x = X_predictors2, y = Y_response, method = \"msn\", k = k)\n# and mahalanobis\nmal_dist_6 &lt;- yai(x = X_predictors2, y = Y_response, method = \"mahalanobis\", k = k)\n\n# Small predictors but standarcized\nzmsn_dist_3 &lt;- yai(x = zX_predictors1, y = zY_response, method = \"msn\", k = k)\n# and mahalanobis\nzmal_dist_3 &lt;- yai(x = zX_predictors1, y = zY_response, method = \"mahalanobis\", k = k)\n\n# Standardized expanded\nzmsn_dist_6 &lt;- yai(x = zX_predictors2, y = zY_response, method = \"msn\", k = k)\n# and mahalanobis\nzmal_dist_6 &lt;- yai(x = zX_predictors2, y = zY_response, method = \"mahalanobis\", k = k)\n\n\nimputed_msn_dist_3 &lt;- impute(msn_dist_3)\n# imputed_mal_dist_1 &lt;- impute(mal_dist_1)\nimputed_msn_dist_6 &lt;- impute(msn_dist_6)\n# imputed_mal_dist_2 &lt;- impute(mal_dist_2)\nimputed_zmsn_dist_3 &lt;- impute(zmsn_dist_3)\n# imputed_zmal_dist_1 &lt;- impute(zmal_dist_1)\nimputed_zmsn_dist_6 &lt;- impute(zmsn_dist_6)\n# imputed_zmal_dist_2 &lt;- impute(zmal_dist_2)\n\nnames &lt;- c('PSME_TD', 'PICO_TD', 'PIPO_TD', 'PRVI_TD', 'ABGR_TD', 'PREM_TD', \n           'PSME_TD.o', 'PICO_TD.o', 'PIPO_TD.o', 'PRVI_TD.o', 'ABGR_TD.o', 'PREM_TD.o')\n\nimp_msn_dist_3 &lt;- imputed_msn_dist_3[, names(imputed_msn_dist_3) %in% names] |&gt; \n  filter(PSME_TD &lt; 15000 & PSME_TD.o &lt; 15000)\nimp_msn_dist_6 &lt;- imputed_msn_dist_6[, names(imputed_msn_dist_6) %in% names]|&gt; \n  filter(PSME_TD &lt; 15000 & PSME_TD.o &lt; 15000)\nzimp_msn_dist_3 &lt;- imputed_zmsn_dist_3[, names(imputed_zmsn_dist_3) %in% names]|&gt; \n  filter(PSME_TD &lt; 15000 & PSME_TD.o &lt; 15000)\nzimp_msn_dist_6 &lt;- imputed_zmsn_dist_6[, names(imputed_zmsn_dist_6) %in% names]|&gt; \n  filter(PSME_TD &lt; 15000 & PSME_TD.o &lt; 15000)"
  },
  {
    "objectID": "2_Imputation.html#set-1-plots",
    "href": "2_Imputation.html#set-1-plots",
    "title": "Imputation",
    "section": "Set 1 Plots",
    "text": "Set 1 Plots\nHere are imputed vs observed when using ither the Kralicek 3 variables or adding elev, slope, and aspect for the 6 variable ones.\n\nplot(imp_msn_dist_3)\nplot(imp_msn_dist_6)\n\n\n\n\n\n\n\n\n\n\n\n\nHere are the three vs six variable plots, but this time, z is for zero. As in there are no zeroes in response variabeles. z means these are only for plots that have seedlings.\n\nplot(zimp_msn_dist_3)\nplot(zimp_msn_dist_6)\n\n\n\n\n\n\n\n\n\n\n\n\nThree variables, all plots vs seedling only plots/stands.\n\nplot(imp_msn_dist_3)\nplot(zimp_msn_dist_3)\n\n\n\n\n\n\n\n\n\n\n\n\nSix variable plots, all stands vs seeldings only.\n\nplot(imp_msn_dist_6)\nplot(zimp_msn_dist_6)"
  },
  {
    "objectID": "2_Imputation.html#set-2",
    "href": "2_Imputation.html#set-2",
    "title": "Imputation",
    "section": "Set 2",
    "text": "Set 2\nI am skipping a set of imputations I did before, in attempt 4 fpag. That one was a failure because FPAG couldn’t be added to the distance matrix. I couldn’t use it with MSN, I don’t think I have tried to use it with RF yet.\nThis set of code is from CH 14 in the regen book.\n\nrm(list = ls())\n\nk = 10\n\n# Pulling from my new interim save point\ncon &lt;- dbConnect(RSQLite::SQLite(), \"./attempt_032524.db\")\nimp_data &lt;- dbGetQuery(con, \"select * from imp_data\")\nzimp_data &lt;- dbGetQuery(con, \"select * from regen_only_imp_data\")\nplots &lt;- dbGetQuery(con, \"select * from fvs_plotinit_plot\")\nplants_ref &lt;- dbGetQuery(con, \"select * from plants_ref\")\ndbDisconnect(con)\nrm(con)\n\nimp_data_orig &lt;- imp_data\n\n# Grabbing the topography variables\npred_topo &lt;- plots |&gt; select(\n  STANDPLOT_CN, ELEVFT, SLOPE, ASPECT\n)\n# Get the Kralicek variables\npred_Kral &lt;- imp_data |&gt; select(\n  STANDPLOT_CN, CC, BA, SDI, FPAG\n)\n\n# remove the predictors from the response.\nresponse &lt;- imp_data |&gt; select(\n  -c(CC, BA, SDI, FPAG)\n)\n# join the Kralicek and topo variables. \npredictors &lt;- left_join(pred_Kral, pred_topo)|&gt; \n  relocate(FPAG, .after = STANDPLOT_CN)\n\nJoining with `by = join_by(STANDPLOT_CN)`\n\nunique(imp_data$FPAG)\n\n  [1] \"CWF4\" \"CDS6\" \"CDS2\" \"CAS3\" \"CDG1\" \"CMS3\" \"CWS5\" \"CHS1\" \"CES4\" \"CES2\"\n [11] \"CES1\" \"CAC1\" \"CPS2\" \"CDS7\" \"CPG1\" \"CEF2\" \"CPS5\" \"CES3\" \"CDS8\" \"CD\"  \n [21] \"CWG1\" \"CWS2\" \"CWF2\" \"CP\"   \"CF\"   \"CFF2\" \"CEG3\" \"CMS2\" \"CHF2\" \"CW\"  \n [31] \"HC\"   \"CC\"   \"CEF4\" \"CAG1\" \"CDG3\" \"CDS4\" \"CES\"  \"CFS5\" \"CEM2\" \"CHS4\"\n [41] \"CCS2\" \"CCF2\" \"CHF3\" \"CH\"   \"CWS4\" \"CFS6\" \"CFS2\" \"CFS4\" \"HO\"   \"CE\"  \n [51] \"CLS5\" \"CWS3\" \"CWS8\" \"CCS3\" \"HQS2\" \"CHS2\" \"CFS3\" \"CEF1\" \"CHF1\" \"CPG2\"\n [61] \"CMS1\" \"CFF1\" \"HOG2\" \"CWF3\" \"HOG1\" \"CMF1\" \"CMG2\" \"CEG1\" \"CDS\"  \"CE41\"\n [71] \"CW61\" \"CCHS\" \"CDS1\" \"CEFH\" \"CD81\" \"CEFA\" \"CW55\" \"CAG2\" \"CAS4\" \"CHF4\"\n [81] \"CDG2\" \"HQG1\" \"CHS7\" \"CAS2\" \"HQM2\" \"CDF4\" \"HX\"   \"CHS6\" \"CMS5\" \"CHC2\"\n [91] \"HQ\"   \"HOG3\" \"CD27\" \"HOS6\" \"HOS3\" \"CWC4\" \"CPS3\" \"HAM1\" \"CEM3\" \"CA\"  \n[101] \"CWGI\" \"SW72\" \"CL\"   \"CD63\" \"CDH4\" \"CPS0\" \"CPG0\" \"CD61\" \"CWF5\" \"CEG2\"\n[111] \"CDF0\" \"CPF0\" \"CERR\" \"CWF0\" \"CEFM\" \"HOC2\" \"CHF5\" \"CACE\" \"CS\"   \"CM\"  \n[121] \"CEN2\" \"CDGE\" \"cds7\" \"HCS3\" \"HQS0\" \"HCS1\" \"CM53\" \"CDG6\" \"CS53\" \"CEM1\"\n[131] \"CE54\" \"CDS5\" \"CES5\" \"HAS3\" \"CEF3\" \"CAGO\" \"CAC5\" \"SW21\" \"CAF3\" \"HOS1\"\n[141] \"HA\"   \"CDS3\" \"CW33\" \"CLM4\" \"CFF4\" \"CFS1\" \"CHS5\" \"HB\"   \"CH21\" \"CHS3\"\n[151] \"CMS4\" \"chs5\" \"CSF1\" \"CAG3\" \"CHM1\" \"CLS3\" \"HBS1\" \"CFF3\" \"CAF2\" \"CMF2\"\n[161] \"SM20\" \"CFS\"  \"CHFS\" \"CH62\" \"CFM1\" \"CHMI\" \"HBM1\" \"CFRR\" \"CHD1\" \"CHS8\"\n[171] \"CHF9\" \"CHFI\" \"CHSI\" \"HAM0\" \"CLS4\" \"SM81\" \"CLS2\" \"CES6\" \"CSF2\" \"CFSC\"\n[181] \"CHF\"  \"CHS9\" \"CH6-\" \"CSF3\" \"HM\"   \"HD\"   \"CFS-\" \"SM40\" \"CHF6\" \"CHS\" \n[191] \"CAS-\" \"CDRX\" \"HAS1\" \"CH12\" \"CHF0\" \"HCD1\" \"CM55\" \"HAF\" \n\n\n\nimp_data |&gt; group_by(FPAG) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(desc(n)) |&gt; head()\n\n# A tibble: 6 × 2\n  FPAG      n\n  &lt;chr&gt; &lt;int&gt;\n1 CDS6   2396\n2 CFS2   2004\n3 CHS1   1524\n4 CHF1   1462\n5 CDS7   1352\n6 CDG1   1090\n\n\n\nimp_data_FPA &lt;- imp_data |&gt; \n  mutate(\n    fpa = str_sub(FPAG, 1, 3)\n  )\n\nx &lt;- unique(imp_data_FPA$fpa)\nx\n\n [1] \"CWF\" \"CDS\" \"CAS\" \"CDG\" \"CMS\" \"CWS\" \"CHS\" \"CES\" \"CAC\" \"CPS\" \"CPG\" \"CEF\"\n[13] \"CD\"  \"CWG\" \"CP\"  \"CF\"  \"CFF\" \"CEG\" \"CHF\" \"CW\"  \"HC\"  \"CC\"  \"CAG\" \"CFS\"\n[25] \"CEM\" \"CCS\" \"CCF\" \"CH\"  \"HO\"  \"CE\"  \"CLS\" \"HQS\" \"HOG\" \"CMF\" \"CMG\" \"CE4\"\n[37] \"CW6\" \"CCH\" \"CD8\" \"CW5\" \"HQG\" \"HQM\" \"CDF\" \"HX\"  \"CHC\" \"HQ\"  \"CD2\" \"HOS\"\n[49] \"CWC\" \"HAM\" \"CA\"  \"SW7\" \"CL\"  \"CD6\" \"CDH\" \"CPF\" \"CER\" \"HOC\" \"CS\"  \"CM\" \n[61] \"CEN\" \"cds\" \"HCS\" \"CM5\" \"CS5\" \"CE5\" \"HAS\" \"SW2\" \"CAF\" \"HA\"  \"CW3\" \"CLM\"\n[73] \"HB\"  \"CH2\" \"chs\" \"CSF\" \"CHM\" \"HBS\" \"SM2\" \"CH6\" \"CFM\" \"HBM\" \"CFR\" \"CHD\"\n[85] \"SM8\" \"HM\"  \"HD\"  \"SM4\" \"CDR\" \"CH1\" \"HCD\" \"HAF\"\n\n\n\n# There are 17 fpas vs 34 FPAGs\nn_distinct(imp_data_FPA$fpa)\n\n[1] 92\n\nn_distinct(imp_data_FPA$FPAG)\n\n[1] 198\n\n# n_distinct(imp_data$FPAG)\n\n# There are 4028 vs 2402 in the largest group\nimp_data_FPA |&gt; group_by(fpa) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(desc(n)) |&gt; head()\n\n# A tibble: 6 × 2\n  fpa       n\n  &lt;chr&gt; &lt;int&gt;\n1 CDS    4615\n2 CFS    2945\n3 CHS    2520\n4 CHF    2430\n5 CES    2055\n6 CMS    1532\n\n\nBefore expanding the set, there were 17 fpas and 34 fpags. Now there are 92 fpas and 198 FPAGs\nHere is the table before:\n\n\n\nfpa\nn\n\n\n\n\nCDS\n4028\n\n\nCES\n2004\n\n\nCFS\n1840\n\n\nCDG\n1383\n\n\nCMS\n1221\n\n\nCHS\n1220\n\n\n\n\nSpecies prevalence\n\nz &lt;- apply(imp_data, 2, max) \nz &lt;- z[6:length(z)]\nx &lt;- names(z)\ny &lt;- z\nnames(y) &lt;- NULL\ny &lt;- as.numeric(y)\nnames(y) &lt;- x\n# This is a sorted list of the maximum trees per acre per species on one plot\ny |&gt; sort(decreasing = T)\n\n    TSHE_TD     PIEN_TD     ACGL_TD     PICO_TD     PSME_TD     THPL_TD \n47527.98907 24588.61264 24063.85567 18816.28590 15142.98705 14768.16064 \n    ABGR_TD     ABAM_TD     BEPA_TD     LAOC_TD     PIPO_TD     FRLA_TD \n13793.61197 12219.34104 10944.93124 10345.20898  9070.79918  8770.93805 \n    ABLA_TD     MAFU_TD     TSME_TD     PRVI_TD     PREM_TD     CHNO_TD \n 7796.38937  7196.66712  4722.81279  4347.98638  3523.36827  3148.54186 \n   POTR5_TD     ABPR_TD     LALY_TD    TABR2_TD    ALRU2_TD     PRAV_TD \n 2773.71545  2623.78489  2548.81960  2248.95847  2248.95847  2248.95847 \n   QUGA4_TD    PIMO3_TD    POBAT_TD     ABCO_TD    ACMA3_TD     PIAL_TD \n 2099.02791  1874.13206  1274.40980  1274.40980  1049.51395   974.54867 \n    PISI_TD    CONU4_TD      2TB_TD    ALRH2_TD     JUOC_TD     CHLA_TD \n  674.68754   449.79170   449.79170   449.79170   374.82641   374.82640 \n    ARME_TD    PRPE2_TD     JUNI_TD    BEOC2_TD     PSMA_TD     BEUT_TD \n  224.89585   224.89585   149.93060   149.93057    74.96528    74.96528 \n    JUHI_TD \n   74.96528 \n\nimp &lt;- imp_data\n\nimp_p &lt;- imp |&gt; select(1:5)\nimp_r &lt;- imp |&gt; select(1, 6:ncol(imp))\nimp_r &lt;- imp_r |&gt; mutate(\n  total_TD = rowSums(imp_r[,2:ncol(imp_r)])\n)\n\nimp &lt;- left_join(imp_p, imp_r, by = \"STANDPLOT_CN\")\nimp_z &lt;- imp[imp$total_TD &gt; 0,]\n\n# summary(imp_z[,6:ncol(imp_z)])\n\n\n\napply(imp_z[,6:ncol(imp_z)], 2, quantile, seq(0.72, 0.90, .04))\n\n     ABGR_TD PIPO_TD   PSME_TD PIAL_TD   ABLA_TD TSME_TD LALY_TD   ABAM_TD\n72%  0.00000       0   0.00000       0   0.00000       0       0   0.00000\n76%  0.00000       0   0.00000       0   0.00000       0       0  74.96528\n80%  0.00000       0  74.96528       0   0.00000       0       0  74.96528\n84%  0.00000       0  74.96528       0  74.96528       0       0 224.89585\n88% 74.96528       0 149.93057       0 149.93057       0       0 374.82641\n    THPL_TD PIEN_TD   TSHE_TD ACGL_TD PICO_TD LAOC_TD TABR2_TD CHNO_TD BEPA_TD\n72%       0       0   0.00000       0       0       0        0       0       0\n76%       0       0   0.00000       0       0       0        0       0       0\n80%       0       0   0.00000       0       0       0        0       0       0\n84%       0       0  74.96528       0       0       0        0       0       0\n88%       0       0 149.93057       0       0       0        0       0       0\n    PREM_TD ABPR_TD PIMO3_TD PRVI_TD POTR5_TD ALRU2_TD QUGA4_TD CONU4_TD\n72%       0       0        0       0        0        0        0        0\n76%       0       0        0       0        0        0        0        0\n80%       0       0        0       0        0        0        0        0\n84%       0       0        0       0        0        0        0        0\n88%       0       0        0       0        0        0        0        0\n    ACMA3_TD JUOC_TD FRLA_TD 2TB_TD POBAT_TD MAFU_TD ARME_TD ABCO_TD PISI_TD\n72%        0       0       0      0        0       0       0       0       0\n76%        0       0       0      0        0       0       0       0       0\n80%        0       0       0      0        0       0       0       0       0\n84%        0       0       0      0        0       0       0       0       0\n88%        0       0       0      0        0       0       0       0       0\n    PSMA_TD ALRH2_TD JUNI_TD BEUT_TD BEOC2_TD PRPE2_TD JUHI_TD CHLA_TD PRAV_TD\n72%       0        0       0       0        0        0       0       0       0\n76%       0        0       0       0        0        0       0       0       0\n80%       0        0       0       0        0        0       0       0       0\n84%       0        0       0       0        0        0       0       0       0\n88%       0        0       0       0        0        0       0       0       0\n     total_TD\n72%  599.7223\n76%  749.6528\n80%  899.5834\n84% 1124.4792\n88% 1349.3751\n\nprevalent_sp &lt;- c('PSME_TD', 'ABAM_TD', 'ABLA_TD', 'TSHE_TD')\nkeep &lt;- names(imp_z)[!names(imp_z) %in% prevalent_sp]\n\nimp_z2 &lt;- imp_z[,keep]\n\napply(imp_z2[,6:ncol(imp_z2)], 2, quantile, seq(0.90, 0.9875, .025))\n\n        ABGR_TD  PIPO_TD PIAL_TD   TSME_TD LALY_TD   THPL_TD  PIEN_TD ACGL_TD\n90%    74.96528  0.00000       0   0.00000       0  74.96528  0.00000       0\n92.5% 149.93057  0.00000       0   0.00000       0  74.96528  0.00000       0\n95%   299.86113 74.96528       0  74.96528       0 149.93057 74.96528       0\n97.5% 524.75698 74.96528       0 224.89585       0 374.82641 74.96528       0\n        PICO_TD LAOC_TD TABR2_TD CHNO_TD BEPA_TD PREM_TD ABPR_TD PIMO3_TD\n90%     0.00000       0        0       0       0       0       0  0.00000\n92.5%   0.00000       0        0       0       0       0       0  0.00000\n95%    74.96528       0        0       0       0       0       0  0.00000\n97.5% 299.86113       0        0       0       0       0       0 74.96528\n      PRVI_TD POTR5_TD ALRU2_TD QUGA4_TD CONU4_TD ACMA3_TD JUOC_TD FRLA_TD\n90%         0        0        0        0        0        0       0       0\n92.5%       0        0        0        0        0        0       0       0\n95%         0        0        0        0        0        0       0       0\n97.5%       0        0        0        0        0        0       0       0\n      2TB_TD POBAT_TD MAFU_TD ARME_TD ABCO_TD PISI_TD PSMA_TD ALRH2_TD JUNI_TD\n90%        0        0       0       0       0       0       0        0       0\n92.5%      0        0       0       0       0       0       0        0       0\n95%        0        0       0       0       0       0       0        0       0\n97.5%      0        0       0       0       0       0       0        0       0\n      BEUT_TD BEOC2_TD PRPE2_TD JUHI_TD CHLA_TD PRAV_TD total_TD\n90%         0        0        0       0       0       0 1574.271\n92.5%       0        0        0       0       0       0 1874.132\n95%         0        0        0       0       0       0 2443.868\n97.5%       0        0        0       0       0       0 3448.403\n\ncommon_sp &lt;- c('PIPO_TD' , 'TSME_TD', 'ABGR_TD', 'THPL_TD', 'PIEN_TD', 'PICO_TD', 'PIMO3_TD')\n\nkeep &lt;- names(imp_z2)[!names(imp_z2) %in% common_sp]\nimp_z3 &lt;- imp_z2[,keep]\n\napply(imp_z3[,6:ncol(imp_z3)], 2, quantile, seq(0.975, .99, .005))\n\n       PIAL_TD LALY_TD   ACGL_TD   LAOC_TD TABR2_TD   CHNO_TD BEPA_TD  PREM_TD\n97.5%  0.00000       0   0.00000   0.00000  0.00000   0.00000       0  0.00000\n98%    0.00000       0  74.96528  74.96528  0.00000  74.96528       0  0.00000\n98.5% 74.96528       0  74.96528  74.96528 74.96528 149.93057       0  0.00000\n99%   74.96528       0 149.93057 149.93057 74.96528 224.89585       0 74.96528\n       ABPR_TD PRVI_TD  POTR5_TD ALRU2_TD QUGA4_TD CONU4_TD ACMA3_TD JUOC_TD\n97.5%  0.00000       0   0.00000        0        0        0        0       0\n98%    0.00000       0   0.00000        0        0        0        0       0\n98.5%  0.00000       0  74.96528        0        0        0        0       0\n99%   74.96528       0 149.93057        0        0        0        0       0\n      FRLA_TD 2TB_TD POBAT_TD MAFU_TD ARME_TD ABCO_TD PISI_TD PSMA_TD ALRH2_TD\n97.5%       0      0        0       0       0       0       0       0        0\n98%         0      0        0       0       0       0       0       0        0\n98.5%       0      0        0       0       0       0       0       0        0\n99%         0      0        0       0       0       0       0       0        0\n      JUNI_TD BEUT_TD BEOC2_TD PRPE2_TD JUHI_TD CHLA_TD PRAV_TD total_TD\n97.5%       0       0        0        0       0       0       0 3448.403\n98%         0       0        0        0       0       0       0 3898.195\n98.5%       0       0        0        0       0       0       0 4722.813\n99%         0       0        0        0       0       0       0 5697.361\n\nuncommon_sp &lt;- c('PIAL_TD', 'ACGL_TD', 'LAOC_TD', 'TABR2_TD', 'CHNO_TD', \n                 'POTR5_TD')\n\nkeep &lt;- names(imp_z3)[!names(imp_z3) %in% uncommon_sp]\nimp_z4 &lt;- imp_z3[,keep]\n\napply(imp_z4[,6:ncol(imp_z4)], 2, quantile, seq(0.99, 1, .005))\n\n         LALY_TD  BEPA_TD    PREM_TD    ABPR_TD   PRVI_TD   ALRU2_TD  QUGA4_TD\n99%      0.00000     0.00   74.96528   74.96528    0.0000    0.00000    0.0000\n99.5%   74.96528     0.00  224.89585  109.44931  149.9306   74.96528  149.9306\n100%  2548.81960 10944.93 3523.36827 2623.78489 4347.9864 2248.95847 2099.0279\n      CONU4_TD   ACMA3_TD  JUOC_TD  FRLA_TD   2TB_TD POBAT_TD  MAFU_TD  ARME_TD\n99%     0.0000    0.00000   0.0000    0.000   0.0000     0.00    0.000   0.0000\n99.5%   0.0000   74.96528   0.0000    0.000   0.0000     0.00    0.000   0.0000\n100%  449.7917 1049.51395 374.8264 8770.938 449.7917  1274.41 7196.667 224.8958\n      ABCO_TD  PISI_TD  PSMA_TD ALRH2_TD  JUNI_TD  BEUT_TD BEOC2_TD PRPE2_TD\n99%      0.00   0.0000  0.00000   0.0000   0.0000  0.00000   0.0000   0.0000\n99.5%    0.00   0.0000  0.00000   0.0000   0.0000  0.00000   0.0000   0.0000\n100%  1274.41 674.6875 74.96528 449.7917 149.9306 74.96528 149.9306 224.8958\n       JUHI_TD  CHLA_TD  PRAV_TD  total_TD\n99%    0.00000   0.0000    0.000  5697.361\n99.5%  0.00000   0.0000    0.000  7421.563\n100%  74.96528 374.8264 2248.958 47827.850\n\nrare_sp &lt;- names(imp_z4[,6:(ncol(imp_z4)-1)])\n\nsp_prevalence &lt;-  list(prevalent = prevalent_sp, \n     common = common_sp, \n     uncommon = uncommon_sp, \n     rare = rare_sp)\n# save(sp_prevalence, file = \"sp_prevalence.Rdata\")\n# getwd()\n\nprint(sp_prevalence)\n\n$prevalent\n[1] \"PSME_TD\" \"ABAM_TD\" \"ABLA_TD\" \"TSHE_TD\"\n\n$common\n[1] \"PIPO_TD\"  \"TSME_TD\"  \"ABGR_TD\"  \"THPL_TD\"  \"PIEN_TD\"  \"PICO_TD\"  \"PIMO3_TD\"\n\n$uncommon\n[1] \"PIAL_TD\"  \"ACGL_TD\"  \"LAOC_TD\"  \"TABR2_TD\" \"CHNO_TD\"  \"POTR5_TD\"\n\n$rare\n [1] \"LALY_TD\"  \"BEPA_TD\"  \"PREM_TD\"  \"ABPR_TD\"  \"PRVI_TD\"  \"ALRU2_TD\"\n [7] \"QUGA4_TD\" \"CONU4_TD\" \"ACMA3_TD\" \"JUOC_TD\"  \"FRLA_TD\"  \"2TB_TD\"  \n[13] \"POBAT_TD\" \"MAFU_TD\"  \"ARME_TD\"  \"ABCO_TD\"  \"PISI_TD\"  \"PSMA_TD\" \n[19] \"ALRH2_TD\" \"JUNI_TD\"  \"BEUT_TD\"  \"BEOC2_TD\" \"PRPE2_TD\" \"JUHI_TD\" \n[25] \"CHLA_TD\"  \"PRAV_TD\" \n\n# Here are the quantiles for most prevelant species with zeroes\napply(imp_data[,sp_prevalence$prevalent], 2, quantile, seq(0.86, 1, .01))\n\n         PSME_TD     ABAM_TD    ABLA_TD     TSHE_TD\n86%      0.00000     0.00000    0.00000     0.00000\n87%      0.00000    74.96528    0.00000     0.00000\n88%     74.96528    74.96528    0.00000     0.00000\n89%     74.96528    74.96528    0.00000     0.00000\n90%     74.96528   149.93057    0.00000     0.00000\n91%     74.96528   149.93057    0.00000    74.96528\n92%     74.96528   224.89585   74.96528    74.96528\n93%     74.96528   299.86113   74.96528    74.96528\n94%    149.93057   374.82641  149.93057   149.93057\n95%    149.93057   449.79170  224.89585   224.89585\n96%    224.89585   599.72226  299.86113   224.89585\n97%    299.86113   824.61811  449.79170   449.79170\n98%    374.82641  1124.47924  599.72226   524.75698\n99%    674.68754  1799.16678 1184.45146  1124.47924\n100% 15142.98705 12219.34104 7796.38937 47527.98907\n\n# Here are the quantiles for common species with zeroes\napply(imp_data[,sp_prevalence$common], 2, quantile, seq(0.95, 1, .01))\n\n        PIPO_TD    TSME_TD     ABGR_TD     THPL_TD     PIEN_TD     PICO_TD\n95%     0.00000    0.00000    74.96528    74.96528     0.00000     0.00000\n96%     0.00000    0.00000   149.93057    74.96528     0.00000     0.00000\n97%     0.00000   74.96528   224.89585   149.93057     0.00000    74.96528\n98%    74.96528   74.96528   374.82641   224.89585    74.96528   149.93057\n99%   149.93057  224.89585   674.68754   449.79170   149.93057   449.79170\n100% 9070.79918 4722.81279 13793.61197 14768.16064 24588.61264 18816.28590\n       PIMO3_TD\n95%     0.00000\n96%     0.00000\n97%     0.00000\n98%     0.00000\n99%    74.96528\n100% 1874.13206\n\n# Here are the quantiles for uncommon species with zeroes\napply(imp_data[,sp_prevalence$uncommon], 2, quantile, seq(0.9875, 1, .0025))\n\n         PIAL_TD     ACGL_TD     LAOC_TD   TABR2_TD    CHNO_TD   POTR5_TD\n98.75%   0.00000     0.00000    74.96528    0.00000   74.96528    0.00000\n99%      0.00000    74.96528    74.96528    0.00000   74.96528    0.00000\n99.25%  74.96528    74.96528    74.96528   74.96528  149.93057   74.96528\n99.5%   74.96528   149.93057   149.93057   74.96528  292.36460  149.93057\n99.75% 149.93057   449.79170   449.79170  224.89585  449.79170  299.86113\n100%   974.54867 24063.85567 10345.20898 2248.95847 3148.54186 2773.71545\n\n# Here are the quantiles for rare species with zeroes\napply(imp_data[,sp_prevalence$rare], 2, quantile, seq(0.9925, 1, .0025))\n\n          LALY_TD  BEPA_TD    PREM_TD    ABPR_TD   PRVI_TD   ALRU2_TD\n99.25%    0.00000     0.00    0.00000    0.00000    0.0000    0.00000\n99.5%     0.00000     0.00   74.96528   74.96528    0.0000    0.00000\n99.75%   74.96528     0.00  224.89585  149.93057  149.9306   74.96528\n100%   2548.81960 10944.93 3523.36827 2623.78489 4347.9864 2248.95847\n         QUGA4_TD CONU4_TD   ACMA3_TD  JUOC_TD  FRLA_TD   2TB_TD POBAT_TD\n99.25%    0.00000   0.0000    0.00000   0.0000    0.000   0.0000     0.00\n99.5%    67.46875   0.0000    0.00000   0.0000    0.000   0.0000     0.00\n99.75%  149.93057   0.0000   74.96528   0.0000    0.000   0.0000     0.00\n100%   2099.02791 449.7917 1049.51395 374.8264 8770.938 449.7917  1274.41\n        MAFU_TD  ARME_TD ABCO_TD  PISI_TD  PSMA_TD ALRH2_TD  JUNI_TD  BEUT_TD\n99.25%    0.000   0.0000    0.00   0.0000  0.00000   0.0000   0.0000  0.00000\n99.5%     0.000   0.0000    0.00   0.0000  0.00000   0.0000   0.0000  0.00000\n99.75%    0.000   0.0000    0.00   0.0000  0.00000   0.0000   0.0000  0.00000\n100%   7196.667 224.8958 1274.41 674.6875 74.96528 449.7917 149.9306 74.96528\n       BEOC2_TD PRPE2_TD  JUHI_TD  CHLA_TD  PRAV_TD\n99.25%   0.0000   0.0000  0.00000   0.0000    0.000\n99.5%    0.0000   0.0000  0.00000   0.0000    0.000\n99.75%   0.0000   0.0000  0.00000   0.0000    0.000\n100%   149.9306 224.8958 74.96528 374.8264 2248.958\n\n\n\n\nImp on CDS\n\nCDS &lt;- imp_data_FPA[imp_data_FPA$fpa == \"CDS\", ]\n\nCDS &lt;- CDS |&gt;  mutate(\n  common = rowSums(CDS[,sp_prevalence$common]),\n  uncommon = rowSums(CDS[,sp_prevalence$uncommon]),\n  rare_TD = rowSums(CDS[,sp_prevalence$rare]), \n  total_TD = rowSums((CDS[, 6:39]))\n) |&gt; \n  select(-sp_prevalence$rare, -sp_prevalence$uncommon, -sp_prevalence$common) \n\nCDS &lt;- CDS |&gt; \n  relocate(fpa, .after = FPAG)\n\n\n# Here are the quantiles for most prevelant species with zeroes\napply(CDS[,sp_prevalence$prevalent], 2, quantile, seq(0.99, 1, .001))\n\n         PSME_TD ABAM_TD   ABLA_TD   TSHE_TD\n99%     974.5487       0   0.00000   0.00000\n99.1%  1085.0475       0  74.96528   0.00000\n99.2%  1199.4445       0  74.96528   0.00000\n99.3%  1274.4098       0  74.96528   0.00000\n99.4%  1349.3751       0  74.96528   0.00000\n99.5%  1494.0581       0  74.96528   0.00000\n99.6%  1574.2709       0 149.93057   0.00000\n99.7%  1672.9252       0 149.93057   0.00000\n99.8%  2024.0626       0 224.89585   0.00000\n99.9%  2681.6581       0 357.73433  74.96528\n100%  15142.9871       0 674.68754 299.86113\n\n\nI viewed the table and picked values based on the next highest after the max. I supppose I could also trim the highest values.\n\n# I am replacing the highest value with the next highest value\nCDS$PSME_TD[CDS$PSME_TD &gt; 3148.5] &lt;- 3148.5\n# Removing an All zero column and a nearly empty one. \nCDS &lt;- CDS |&gt; select(-c(ABAM_TD, TSHE_TD))\n\ncds &lt;- CDS\n\nrefs &lt;- cds[1:(3*nrow(cds)/4),]\n\n# CDS\n# cds\n# data(\"MoscowMtStJoe\")\n\nx &lt;- cds |&gt; select(1:4)\nx &lt;- remove_rownames(x)\nx &lt;- column_to_rownames(x, \"STANDPLOT_CN\")\n\ny &lt;- cds |&gt; select(1, 7:ncol(cds))\n# y &lt;- y[refs]\ny &lt;- remove_rownames(y)\ny &lt;- column_to_rownames(y, \"STANDPLOT_CN\")\n\n\n\nmal &lt;- yai(x = x, y = y, method = \"mahalanobis\", k = k)\nmsn &lt;- yai(x = x, y = y, method = \"msn\", k = k)\ngnn &lt;- yai(x = x, y = y, method = \"gnn\", k = k)\n\nWarning in yai(x = x, y = y, method = \"gnn\", k = k): 2944 rows have y-variable\nrow sums &lt;= 0 were converted to target observations for method gnn\n\nica &lt;- yai(x = x, y = y, method = \"ica\", k = k)\n\nLoading required namespace: fastICA\n\nerror_full &lt;- errorStats(mal, msn, gnn, ica)\n\nWarning in notablyDistant(x, p = 1 - pzero): when computing threshold, 441 zero\ndistances of 4615 references were set to 0.0000000002325966\n\n\nWarning in notablyDistant(x, p = plg): when computing threshold, 441 zero\ndistances of 4615 references were set to 0.0000000002325966\n\n\nWarning in notablyDistant(x, p = plg): when computing threshold, 441 zero\ndistances of 4615 references were set to 0.000000000130061\n\n\nWarning in notablyDistant(x, p = plg): when computing threshold, 136 zero\ndistances of 1671 references were set to 0.00000000000000001387779\n\n\nWarning in notablyDistant(x, p = plg): when computing threshold, 441 zero\ndistances of 4615 references were set to 0.0000000002326218\n\nyrf &lt;- cbind(whatsMax(y[ ,1:(ncol(y)-1)]), y[, ncol(y)])\n\nnames(yrf) &lt;- c('Max_SP', 'sp_max_TD', 'total_TD')\n\nrf &lt;- yai(x = x, y = yrf, method = \"randomForest\", k = k)\n\n\n# This won't run with rf in it? \n# error_full &lt;- errorStats(mal, msn, gnn, rf)\n\nFull_set &lt;- impute(rf, ancillaryData = y)\nrmsd &lt;- compare.yai(mal, msn, gnn, Full_set, ica)\n\nWarning in compare.yai(mal, msn, gnn, Full_set, ica): not all scale factors are\nthe same.\n\nrmsd.yai(Full_set)\n\n              rmsd\nPSME_TD  184.93821\nABLA_TD   26.25322\ncommon   250.99828\nuncommon 375.17874\nrare_TD  112.75748\ntotal_TD 426.89532\n\n\nDots below the one to one line indicate lower rmsd for the named imputation on the horizontal.\n\nplot(rmsd, main = \"Full Set\")\n# plot(rmsd_wo_z, main = \"W/o Zero r\")\n# plot(rmsd_wo_zp, main = \"W/o Zero p\")\n\n\npar(mar = c(1,1,3.2,1))\nplot(rf)\n\n\n\n\n\npar(mar = c(1,1,3.2,1))\nplot(msn)\n\n\n\n\n\nrmsd\n\n         mal.rmsdS msn.rmsdS gnn.rmsdS Full_set.rmsdS ica.rmsdS\nPSME_TD  0.9742293 1.0028254 1.0430676      0.8618300 0.9755856\nABLA_TD  1.2163312 1.3051459 1.4111898      1.1612194 1.2163312\ncommon   0.9446253 1.0126262 0.8401424      0.7456694 0.9453418\nuncommon 1.4020282 1.3936819 1.4072269      1.0094385 1.4019401\nrare_TD  1.3471906 1.2835394 1.3637743      1.2121013 1.3629745\ntotal_TD 0.5857362 0.8211703 0.4994699      0.6550530 0.5857362\n\n\n\nfind_best &lt;- function(df) {\n  data.frame(name = names(df)[apply(df, 1, which.min)],\n     value = apply(df, 1, min))\n}\n\nfind_best(rmsd)\n\n                   name     value\nPSME_TD  Full_set.rmsdS 0.8618300\nABLA_TD  Full_set.rmsdS 1.1612194\ncommon   Full_set.rmsdS 0.7456694\nuncommon Full_set.rmsdS 1.0094385\nrare_TD  Full_set.rmsdS 1.2121013\ntotal_TD      gnn.rmsdS 0.4994699"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regen_Notes",
    "section": "",
    "text": "git add .\ngit commit -m “comment”\ngit push origin main\nquarto publish gh-pages\ngit remote set-url origin https://github.com/KingBlkMouth/Regen.git\ngit remote -v"
  },
  {
    "objectID": "index.html#these-are-git-commands-that-i-need",
    "href": "index.html#these-are-git-commands-that-i-need",
    "title": "Regen_Notes",
    "section": "",
    "text": "git add .\ngit commit -m “comment”\ngit push origin main\nquarto publish gh-pages\ngit remote set-url origin https://github.com/KingBlkMouth/Regen.git\ngit remote -v"
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Regen_Notes",
    "section": "Contents",
    "text": "Contents\nThere are many absolute paths in plot selection.\n\nPlot Selection\n\nPlot selection\n\nSelect eco-regions and associated plots\n\nCh 4\n\nRemove artificial, unsampled, non-forest, and periodic plots\n\nCh 5\n\nSelect subplots from plots,\nControl for equal conditions.\nClean FPAGs.\nSelect FVS ready data from subplot list\nWrite an input FVS database and standlist.\n\nCh 6\n\nSet: run name, input database, & standlist\nRun plots in FVS to get canopy cover.\n\nImputation Prep\n\nOrganizing the data like yaImpute did in the St.Joe example.\nSaving the clean data.\n\n\nImputation\n\n\n\n\n\n\nunordered list\n\nsub-item 1\nsub-item 2\n\nsub-sub-item 1"
  },
  {
    "objectID": "index.html#plot-selection",
    "href": "index.html#plot-selection",
    "title": "Regen_Notes",
    "section": "Plot Selection",
    "text": "Plot Selection\nPlot Selection, Starting from a set of stands clipped from the study area in Arc Pro, Pull all of the ecoregions in the study area, then pull all stands with those ecoregions from the WA fia database.\nCh4, Pull the plot and condition tables from FIA. Control for artificial regen, unsampled CNs, non-forest conditions, and periodic plot designs. Check the ecoregion codes for mistakes and unwanted codes. Remove the condition CNs that are there only to indicate a site condition.\nCh5, Pull in the subplot’s plot and condition tables. Select only those subplots that have the same conditions on the microplot and subplot. Join the sub conditions table to with those plots that have the same conditions. Select those subplots that are at least 97.5% covered by the same conditions. Remove and habitat types that are coded as admin, non-veg, or water. Manually correct any mislabeled habitat types.\nFVS Prep, Pull in the FVS_Ready tables. Create a column for FPAG. Compare some stats with Kralicek. Write the FVS_Ready and FPAG tables to a .db. Write a standlist for FVS.\nCh6, Run the standlist and the new database in FVS to get Canopy Cover."
  },
  {
    "objectID": "index.html#imputation",
    "href": "index.html#imputation",
    "title": "Regen_Notes",
    "section": "Imputation",
    "text": "Imputation"
  }
]