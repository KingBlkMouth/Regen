[
  {
    "objectID": "scratch.html",
    "href": "scratch.html",
    "title": "Non-FVS variables",
    "section": "",
    "text": "library(tidyverse)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\nstandlist &lt;- read_csv(\"C:/RxFire/Regen/Regen_Notes/standlist03242024.csv\", \n                      col_types = c(\"cccc\")) \n\nn_distinct(standlist$STAND_CN)\n\n[1] 7257\n\nSTAND_CN &lt;- NULL\nSTAND_CN &lt;- str_c(\"'\", unique(standlist$STAND_CN), \"'\")\nSTAND_CN &lt;- str_flatten_comma(STAND_CN)\n\n# COND::BALIVE Basal area per acre of livetrees\nsubcond &lt;- dbGetQuery(con, str_c(\n  \"select * from subp_cond where PLT_CN IN (\", STAND_CN, \")\"))\ncond &lt;- dbGetQuery(con, str_c(\n  \"select * from cond where PLT_CN IN (\", STAND_CN, \")\"))\n\n# P2VEG_STR::COVER_PCT, NT AND TT ARE TREES. \nveg &lt;- dbGetQuery(con, str_c(\n  \"select * from P2VEG_SUBP_STRUCTURE where PLT_CN IN (\", STAND_CN, \")\"))\n\ntree &lt;- dbGetQuery(con, str_c(\n  \"select * from FVS_TREEINIT_PLOT where STAND_CN IN (\", STAND_CN, \")\"))\n\nsubcond &lt;- subcond |&gt; \n  mutate(\n    STANDPLOT_CN = str_c(as.character(PLT_CN), \"_\", as.character(SUBP))\n  )\ns &lt;- subcond |&gt; select(PLT_CN, STANDPLOT_CN, SUBP, CONDID, )\n\nc &lt;- left_join(s, cond, join_by(PLT_CN, CONDID))\nc2 &lt;- c |&gt; select(STANDPLOT_CN, BALIVE) |&gt; drop_na()\n\nveg &lt;- veg |&gt; \n  mutate(\n    STANDPLOT_CN = str_c(as.character(PLT_CN), \"_\", as.character(SUBP))\n  )\n\n\nv &lt;- veg |&gt; filter(LAYER == 5)\nv &lt;- v |&gt; filter(GROWTH_HABIT_CD == \"TT\")\n\nv2 &lt;- v |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarise(CC = sum(COVER_PCT))\n\np. 183 FVS essentials.\n\\[\nSDI = \\sum (TPA_i (\\frac{DBH}{10})^{1.605})\n\\] TPA_i is tpa for a tree record.\nSDI is the sum of Trees per acre times the DBH for those trees, divided by ten to the power of 1.605.\nDBH and tpa are in the tree table.\n\nx &lt;- standlist |&gt; select(STANDPLOT_CN)\n\nt &lt;- left_join(x, tree, by = \"STANDPLOT_CN\")\nc &lt;- left_join(x, cond, by = \"STANDPLOT_CN\")\nv &lt;- left_join(x, veg, by = \"STANDPLOT_CN\")\n\ntpa &lt;- t |&gt; \n  mutate(sdi = (TREE_COUNT * ((DIAMETER/10)^1.605)))\n\nsdi &lt;- tpa[tpa$HISTORY == 1, ] |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarize(SDI = sum(sdi)) |&gt; drop_na()\n\n\ny &lt;- left_join(x, sdi, by = \"STANDPLOT_CN\")\n\ny &lt;- left_join(y, c2, by = \"STANDPLOT_CN\")\n\ny &lt;- left_join(y, v2, by = \"STANDPLOT_CN\")\n\nCanopy cover is not well predicted by the p2veg tables."
  },
  {
    "objectID": "1_Copied_Code.html",
    "href": "1_Copied_Code.html",
    "title": "Plot Selection",
    "section": "",
    "text": "The following code is pulled from my last set of notes in the stated chapters. It has all been updated as of Mar 23 2024.\nTo do\nThe code on this page goes from a shapefile and FIA data to FVS’s computed variables. ___"
  },
  {
    "objectID": "1_Copied_Code.html#plot-selection",
    "href": "1_Copied_Code.html#plot-selection",
    "title": "Plot Selection",
    "section": "Plot selection",
    "text": "Plot selection\n\nlibrary(tidyverse)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\nPrevious steps:\n\nI pulled the lat and long from the FIA’s WA database.\nCreated a point cloud from the coordinates table in Arc Pro.\nClipped the point cloud with POC3/OKWEN/OKWEN_shapefiles/OKWEN_AllFOAs_60km_buffer.shp\nSaved the clipped points to 60k_buffer_fiaplots.csv.\n\nIn the following code:\n\nConnect to the WA FIA .db\nSummarize the eco regions present in the foa boundary.\nlist the eco regions in the study area.\nextract all eco regions in WA that are in our study area and the FVS_Ready data.\n\n\n\nCode\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# This is the selection of plots by lat long from the okwen all foas 60k buffer. \nfoa_60_plots &lt;- read.csv(\"C:/RxFire/Regen/60k_buffer_fiaPlots.csv\")\n\n# Matching the foa cns to the table with ecoregions. \ncns &lt;- foa_60_plots |&gt; select(CN)\n\n# dbListTables(con)\n# dbListFields(con, \"FVS_PLOTINIT_PLOT\")\n\nplots &lt;- dbGetQuery(con, \"SELECT STAND_CN, STANDPLOT_CN, ECOREGION FROM FVS_PLOTINIT_PLOT\")\n\ncns$CN &lt;- as.character(cns$CN)\n\n# 45304 plots\nplots_60 &lt;- left_join(cns, plots, join_by(CN == STAND_CN))\n\n# Checking the number of NAs\nprint(\"There are this many NAs\")\n\n\n[1] \"There are this many NAs\"\n\n\nCode\nnrow(plots_60) - nrow(drop_na(plots_60))\n\n\n[1] 1436\n\n\nCode\nplots_60 &lt;- drop_na(plots_60)\n\ndbDisconnect(con)\n\n\nn_ecos &lt;- plots_60 |&gt; group_by(ECOREGION) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(desc(n))\n\n# Create a list of ecoregions in the study area. \n# The first time, I used gen_eco, that was too broad. \neco_list &lt;- n_ecos |&gt; \n  mutate(\n    gen_eco = str_sub(ECOREGION, 1, -2)\n  )\n# Pull all plots in those ecoregions. \n# nsa_plots &lt;- plots |&gt; mutate(\n#   gen_eco = str_sub(ECOREGION, 1, -2)) |&gt; \n#   filter(gen_eco %in% eco_list$gen_eco)\n\nnsa_plots &lt;- plots |&gt; mutate(\n  gen_eco = str_sub(ECOREGION, 1, -2)) |&gt; \n  filter(ECOREGION %in% eco_list$ECOREGION)\n\n# 59,800 plots w/gen_eco, 58878 w/ecoregion\n# save(nsa_plots, file = \"nsa_plots.Rdata\")\n\nrm(list = ls()[!ls() %in% c(\"nsa_plots\")])"
  },
  {
    "objectID": "1_Copied_Code.html#ch4",
    "href": "1_Copied_Code.html#ch4",
    "title": "Plot Selection",
    "section": "Ch4",
    "text": "Ch4\n\nlibrary(tidyverse, warn.conflicts = F)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\n# nsa_plots &lt;- read_csv(\"C:/RxFire/Regen/Species_Plot_ecotype/FIA_NSA_Nat_design_NEWWA.csv\",\n#                       col_types = c(\"c\"))\n\nload(\"./nsa_plots.Rdata\")\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# Making a list to pull from the big database'\n# This requires less RAM than loading in the database. \nstandlist &lt;- NULL\nstandlist &lt;- str_c(\"'\", nsa_plots$STAND_CN, \"'\")\nstandlist &lt;- str_flatten_comma(standlist)\n\n# Pulling the tables\nztree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE PLT_CN IN (\", standlist, \")\"))\nzplot &lt;- dbGetQuery(con, str_c(\"select * from plot WHERE CN IN (\", standlist, \")\"))\nzp2veg &lt;- dbGetQuery(con, str_c(\"select * from P2VEG_SUBPLOT_SPP WHERE PLT_CN IN (\", standlist, \")\"))\nSPGRPkey &lt;- dbGetQuery(con,\"select * from REF_SPECIES_GROUP\")\n\n\n# Removing empty fields\nzplot &lt;- zplot[, colSums(is.na(zplot)) &lt; nrow(zplot)]\n# zstand &lt;- zstand[, colSums(is.na(zstand)) &lt; nrow(zstand)]\nztree &lt;- ztree[, colSums(is.na(ztree)) &lt; nrow(ztree)]\n# ztree_init &lt;- ztree_init[, colSums(is.na(ztree_init)) &lt; nrow(ztree_init)] \nzp2veg &lt;- zp2veg[, colSums(is.na(zp2veg)) &lt; nrow(zp2veg)]\n\nzcond &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE PLT_CN IN (\", standlist, \")\"))\nzcond &lt;- zcond[, colSums(is.na(zcond)) &lt; nrow(zcond)]\n\nprint(\"the number of condition CNs in the standlist:\") \n\n[1] \"the number of condition CNs in the standlist:\"\n\ndim(zcond)\n\n[1] 19599    98\n\n# Remove artificial regeneration, keep NAs and zeros. \nzcond &lt;- zcond |&gt; filter(\n  STDORGCD == 0 | is.na(STDORGCD)\n)\nprint(\"after controlling for artificial regen\")\n\n[1] \"after controlling for artificial regen\"\n\ndim(zcond)\n\n[1] 18049    98\n\n# # Altered: remove all non-forest conditions. \n# Remove Non-Forested Conditions related to man. \n# unique(zcond$PRESNFCD)\nzcond &lt;- zcond |&gt; filter(\n  (is.na(PRESNFCD))\n)\nprint(\"after controlling for non-forest conditions\")\n\n[1] \"after controlling for non-forest conditions\"\n\ndim(zcond)\n\n[1] 11377    98\n\n# Remove unsampled plots and water\nzcond &lt;- zcond |&gt; filter(\n  COND_STATUS_CD == 1 | is.na(COND_STATUS_CD) | COND_STATUS_CD == 2\n)\n\n\n\n# Remove unsampled plots. \nzcond &lt;- zcond |&gt; filter(\n  is.na(COND_NONSAMPLE_REASN_CD)\n)\nprint(\"after controlling for unsampled and water\")\n\n[1] \"after controlling for unsampled and water\"\n\ndim(zcond)\n\n[1] 9880   98\n\n# There should also be a line for removing the periodic visits, \n# KINDCD = 0.\nzplot &lt;- zplot |&gt; filter(\n  KINDCD != 0\n)\nx &lt;- zplot |&gt; select(PLT_CN = CN, KINDCD)\ny &lt;- left_join(zcond, x, by = \"PLT_CN\")\nzcond &lt;- drop_na(y, KINDCD)\n\nprint(\"after controlling for periodic visits\")\n\n[1] \"after controlling for periodic visits\"\n\ndim(zcond)\n\n[1] 9145   99\n\nzcond &lt;- zcond |&gt; select(\n  CN, PLT_CN, CONDID, HABTYPCD = HABTYPCD1)\n\nzcond &lt;- zcond |&gt; mutate(\n  FPAG = str_remove_all(str_sub(HABTYPCD, 1, 4), \" \")\n)\n\n# NAs in FPAG\nna &lt;- zcond |&gt; filter(is.na(FPAG))\n# good needs some cleaning\ngood &lt;- zcond |&gt; filter(!is.na(FPAG))\n\ngood$PLT_CN &lt;- as.character(good$PLT_CN)\n\n# # Confirming there are no periodic plots. \n# good |&gt; group_by(PLT_CN) |&gt; \n#   summarise(len = str_width(PLT_CN)) |&gt; \n#   arrange(len)\n\n\n\nplants &lt;- read_csv(\"C:/RxFire/Regen/Species_Plot_ecotype/PLANTS.csv\",\n                   col_types = c(\"c\",\"c\",\"c\",\"c\",\"c\"))\n\nplants &lt;- plants |&gt; select(Symbol , Common_Name) |&gt; drop_na()\n# Join the Common Names to the veg list for readability\nzp2veg &lt;- left_join(zp2veg, plants, join_by(\"VEG_SPCD\" == \"Symbol\"))\n\n# Remove extra fields\nzp2veg &lt;- zp2veg |&gt; select(CN,\n  PLT_CN, VEG_SPCD, Common_Name, COVER_PCT, PLOT, SUBP, VEG_FLDSPCD, \n  UNIQUE_SP_NBR, GROWTH_HABIT_CD)\n\n\ntest &lt;- na |&gt; select(CN)\n\n\n# Looking at those NAs\nCN &lt;- NULL\nCN &lt;- str_c(\"'\", test$CN, \"'\")\nCN &lt;- str_flatten_comma(CN)\n\ntest2 &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE CN IN (\", CN, \")\"))\ntest2 &lt;- test2[, colSums(is.na(test2)) &lt; nrow(test2)]\n\ntest &lt;- test2 |&gt; select(CN, PLT_CN)\nPLT_CN &lt;- NULL\nPLT_CN &lt;- str_c(\"'\", test$PLT_CN, \"'\")\nPLT_CN &lt;- str_flatten_comma(PLT_CN)\n\n# all cns that didn't have FPAGs\ntcond &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE CN IN (\", CN, \")\"))\n\n# These plots exist and have trees, but these cond.CN's do not. \n\n# ttree has zero tree records, but tttree does. The stands have trees but not on \n#  those conditions. \nttree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE CN IN (\", CN, \")\"))\ntttree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE PLT_CN IN (\", PLT_CN, \")\"))\n\n# There are 1,319 cond's on 1,268 plots. \n# second time through, there are 276 tconds and 245 tplots. \ntplot &lt;- dbGetQuery(con, str_c(\"select * from plot WHERE CN IN (\", PLT_CN, \")\"))\n\n\nrm(CN, PLT_CN, test, test2, tcond, ttree, tttree, tplot)\nrm(ztree, zplot, zp2veg, zcond, plants, nsa_plots, na)\nrm(standlist)\n\ndbDisconnect(con)\n\ng &lt;- good |&gt; select(PLT_CN, CONDID, HABTYPCD) |&gt; unique()\n\n# write_csv(good, \"./good_plots_03242024.csv\")\n\n6092 stands to use vs 6,337 before."
  },
  {
    "objectID": "1_Copied_Code.html#ch-5",
    "href": "1_Copied_Code.html#ch-5",
    "title": "Plot Selection",
    "section": "CH 5",
    "text": "CH 5\ngood shouldn’t have the short cns. Those are periodic visits.\n\nrm(list = ls())\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# This is just the csv I saved above. \ngood &lt;- read_csv(\"./good_plots_03242024.csv\",\n                 col_types = c(\"ccnc\"))\n\ngood &lt;- good |&gt; select(PLT_CN, CONDID, FPAG) |&gt; unique()\ng &lt;- good |&gt; select(PLT_CN) |&gt; unique()\n\nPLT_CN &lt;- NULL\nPLT_CN &lt;- str_c(\"'\", g$PLT_CN, \"'\")\nPLT_CN &lt;- str_flatten_comma(PLT_CN)\n\nzsubplot &lt;- dbGetQuery(con, str_c(\"select * from subplot WHERE PLT_CN IN (\", PLT_CN, \")\"))\nzsubcond &lt;- dbGetQuery(con, str_c(\"select * from subp_cond WHERE PLT_CN IN (\", PLT_CN, \")\"))\n\n\n# This is every plot and condition that we could sample. \nzsubcond &lt;- left_join(good, zsubcond, join_by(PLT_CN, CONDID))\n\nzsubplot &lt;- zsubplot[, colSums(is.na(zsubplot)) &lt; nrow(zsubplot)]\nzsubcond &lt;- zsubcond[, colSums(is.na(zsubcond)) &lt; nrow(zsubcond)]\n\n# filter for where micro and sup were the same\nzsubplot &lt;- zsubplot |&gt; filter(\n  (MICRCOND == SUBPCOND)\n)\n\n# select all plots with equal conditions and some data for fpag\nzsubkey &lt;- zsubplot |&gt; select(PLT_CN, SUBP) |&gt; unique()\nzcondkey &lt;- zsubcond |&gt; select(PLT_CN, SUBP, FPAG) |&gt; unique()\n#  drop_na()\n\n# Joing them to make a key\nzcon &lt;- left_join(zsubkey, zcondkey, join_by(PLT_CN, SUBP)) |&gt; drop_na()\n\nzsubcond &lt;- zsubcond |&gt; select(\n  PLT_CN, CONDID, FPAG, CN, INVYR, PLOT, SUBP, MICRCOND_PROP, SUBPCOND_PROP, \n  MACRCOND_PROP, NONFR_INCL_PCT_SUBP, NONFR_INCL_PCT_MACRO, CYCLE)\n\n\nunique_conds &lt;- zsubcond |&gt; \n  filter(\n    near(SUBPCOND_PROP, 1, tol = .025) & near(MICRCOND_PROP, 1, tol = .025)\n    )\n\nt &lt;- unique_conds |&gt; select(PLT_CN, SUBP, CN, FPAG)\n\nt &lt;- t |&gt; filter(\n  !startsWith(FPAG, \"A\") & !startsWith(FPAG, \"N\") & !startsWith(FPAG, \"W\")\n)\n\n# I chose CAS4 bc it was the largest group of the three options. \nt &lt;- t |&gt; mutate(\n  FPAG = ifelse(FPAG == \"PIAL\", \"CAGO\", FPAG)\n)\n\nsubs &lt;- t |&gt; rename(SUBPLOT_CN = CN)\n\nunique(t$FPAG) |&gt; sort()\n\n  [1] \"CA\"   \"CAC1\" \"CAC5\" \"CACE\" \"CAF2\" \"CAF3\" \"CAG1\" \"CAG2\" \"CAG3\" \"CAGO\"\n [11] \"CAS-\" \"CAS2\" \"CAS3\" \"CAS4\" \"CC\"   \"CCF2\" \"CCHS\" \"CCS2\" \"CCS3\" \"CD\"  \n [21] \"CD27\" \"CD61\" \"CD63\" \"CD81\" \"CDF0\" \"CDF4\" \"CDG1\" \"CDG2\" \"CDG3\" \"CDG6\"\n [31] \"CDGE\" \"CDH4\" \"CDRX\" \"CDS\"  \"CDS1\" \"CDS2\" \"CDS3\" \"CDS4\" \"CDS5\" \"CDS6\"\n [41] \"cds7\" \"CDS7\" \"CDS8\" \"CE\"   \"CE41\" \"CE54\" \"CEF1\" \"CEF2\" \"CEF3\" \"CEF4\"\n [51] \"CEFA\" \"CEFH\" \"CEFM\" \"CEG1\" \"CEG2\" \"CEG3\" \"CEM1\" \"CEM2\" \"CEM3\" \"CEN2\"\n [61] \"CERR\" \"CES\"  \"CES1\" \"CES2\" \"CES3\" \"CES4\" \"CES5\" \"CES6\" \"CF\"   \"CFF1\"\n [71] \"CFF2\" \"CFF3\" \"CFF4\" \"CFM1\" \"CFRR\" \"CFS\"  \"CFS-\" \"CFS1\" \"CFS2\" \"CFS3\"\n [81] \"CFS4\" \"CFS5\" \"CFS6\" \"CFSC\" \"CH\"   \"CH12\" \"CH21\" \"CH6-\" \"CH62\" \"CHC2\"\n [91] \"CHD1\" \"CHF\"  \"CHF0\" \"CHF1\" \"CHF2\" \"CHF3\" \"CHF4\" \"CHF5\" \"CHF6\" \"CHF9\"\n[101] \"CHFI\" \"CHFS\" \"CHM1\" \"CHMI\" \"CHS\"  \"CHS1\" \"CHS2\" \"CHS3\" \"CHS4\" \"chs5\"\n[111] \"CHS5\" \"CHS6\" \"CHS7\" \"CHS8\" \"CHS9\" \"CHSI\" \"CL\"   \"CLM4\" \"CLS2\" \"CLS3\"\n[121] \"CLS4\" \"CLS5\" \"CM\"   \"CM53\" \"CM55\" \"CMF1\" \"CMF2\" \"CMG2\" \"CMS1\" \"CMS2\"\n[131] \"CMS3\" \"CMS4\" \"CMS5\" \"CP\"   \"CPF0\" \"CPG0\" \"CPG1\" \"CPG2\" \"CPS0\" \"CPS2\"\n[141] \"CPS3\" \"CPS5\" \"CS\"   \"CS53\" \"CSF1\" \"CSF2\" \"CSF3\" \"CW\"   \"CW33\" \"CW55\"\n[151] \"CW61\" \"CWC4\" \"CWF0\" \"CWF2\" \"CWF3\" \"CWF4\" \"CWF5\" \"CWG1\" \"CWGI\" \"CWS2\"\n[161] \"CWS3\" \"CWS4\" \"CWS5\" \"CWS8\" \"HA\"   \"HAF\"  \"HAM0\" \"HAM1\" \"HAS1\" \"HAS3\"\n[171] \"HB\"   \"HBM1\" \"HBS1\" \"HC\"   \"HCD1\" \"HCS1\" \"HCS3\" \"HD\"   \"HM\"   \"HO\"  \n[181] \"HOC2\" \"HOG1\" \"HOG2\" \"HOG3\" \"HOS1\" \"HOS3\" \"HOS6\" \"HQ\"   \"HQG1\" \"HQM2\"\n[191] \"HQS0\" \"HQS2\" \"HX\"   \"SM20\" \"SM40\" \"SM81\" \"SW21\" \"SW22\" \"SW72\"\n\ndbDisconnect(con)\n\nOnly conifer hardwood and shrub classes present.\n\nFVS prep\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# write_csv(subs, \"./good_SUB_plots.csv\")\n\nsubs &lt;- read_csv(\"./good_SUB_plots.csv\",\n                 col_types = c(\"cncc\"))\n\nsubs &lt;- subs |&gt; mutate(\n  STANDPLOT_CN = str_c(PLT_CN, \"_\", SUBP)\n)\n\nSTAND_CN &lt;- NULL\nSTAND_CN &lt;- str_c(\"'\", subs$PLT_CN, \"'\")\nSTAND_CN &lt;- str_flatten_comma(STAND_CN)\n\nSTANDPLOT_CN &lt;- NULL\nSTANDPLOT_CN &lt;- str_c(\"'\", subs$STANDPLOT_CN, \"'\")\nSTANDPLOT_CN &lt;- str_flatten_comma(STANDPLOT_CN)\n\n\nstand &lt;- dbGetQuery(con, \n                    str_c(\"Select * from FVS_STANDINIT_PLOT where STAND_CN IN (\", STAND_CN, \")\"))\n\nplot &lt;- dbGetQuery(con, \n                   str_c(\"Select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN IN (\", STANDPLOT_CN, \")\"))\n\nplot &lt;- plot[, colSums(is.na(plot)) &lt; nrow(plot)]\nstand &lt;- stand[, colSums(is.na(stand)) &lt; nrow(stand)]\n\nplot &lt;- subset(plot, select = -c(GROUPS, INV_MONTH, INV_DAY, DATUM))\n\n\nstand &lt;- subset(stand, select = -c(INV_MONTH, INV_DAY, STATE, COUNTY))\n\n\nt &lt;- plot |&gt; select(STANDPLOT_CN)\n\nt &lt;- left_join(t, subs, by = \"STANDPLOT_CN\")\n\nt &lt;- t |&gt; mutate(\n  FPAG = str_remove_all(str_to_upper(FPAG), \" \")\n)\n\nSTANDPLOT_CN &lt;- NULL\nSTANDPLOT_CN &lt;- str_c(\"'\", t$STANDPLOT_CN, \"'\")\nSTANDPLOT_CN &lt;- str_flatten_comma(STANDPLOT_CN)\n\ntree &lt;- dbGetQuery(con, \n                   str_c(\"Select * from FVS_TREEINIT_PLOT where STANDPLOT_CN IN (\", STANDPLOT_CN, \")\"))\n\ntree &lt;- tree[, colSums(is.na(tree)) &lt; nrow(tree)]\n\n\n# 8701 records\nregen &lt;- tree |&gt; filter(\n  startsWith(TREE_CN, \"S\")\n) |&gt; select(STANDPLOT_CN) |&gt; unique()\n\n\nsubs &lt;- subs[, c(1, 2, 4, 5)]\n\nregen &lt;- left_join(regen, subs, by = \"STANDPLOT_CN\")\n\nrtrees &lt;- left_join(regen, tree, by = \"STANDPLOT_CN\")\n\nt4 &lt;- regen |&gt; group_by(FPAG) |&gt; summarise(n = n()) \n\nprint(\"Median number of subplots where regen occurred is \")\n\n[1] \"Median number of subplots where regen occurred is \"\n\nmedian(t4$n)\n\n[1] 8\n\ns &lt;- subs |&gt; select(STANDPLOT_CN, FPAG)\np &lt;- left_join(plot, s, by = \"STANDPLOT_CN\")\n\np$INV_YEAR &lt;-  2020\n\n\nrm(t, t4)\ndbDisconnect(con)\n\nname &lt;- str_c(\"FVS_inputDB_\", \n              strftime(Sys.Date(),\"%m%d%y\"), \n              \"_\", \n              strftime(Sys.time(),\"%H%M\"),\n              \".db\")\n\n# con = dbConnect(RSQLite::SQLite(), dbname = str_c(\"../\", name)\n# \n# dbWriteTable(conn = con, name = \"FVS_STANDINIT_PLOT\", value = stand, overwrite = T)\n# dbWriteTable(conn = con, name = \"FVS_PLOTINIT_PLOT\", value = p, overwrite = T)\n# dbWriteTable(conn = con, name = \"FVS_TREEINIT_PLOT\", value = tree, overwrite = T)\n# dbListTables(conn = con)\n# dbDisconnect(con)\n\nstandlist &lt;- p |&gt; select(STAND_CN, STANDPLOT_CN, VARIANT, FPAG)\n\nunique(standlist$VARIANT)\n\n[1] \"EC\" \"WC\" \"PN\" \"IE\"\n\nstandlist &lt;- standlist |&gt; mutate(\n  VARIANT = ifelse(VARIANT == \"PN\", \"WC\", VARIANT),\n  VARIANT = ifelse(VARIANT == \"IE\", \"EC\", VARIANT)\n)\nunique(standlist$VARIANT)\n\n[1] \"EC\" \"WC\"\n\nname &lt;- str_c(\"standlist_\", \n              strftime(Sys.Date(),\"%m%d%y\"), \n              \"_\", \n              strftime(Sys.time(),\"%H%M\"),\n              \".csv\")\n\n# write_csv(standlist, str_c(\"./\", name))"
  },
  {
    "objectID": "1_Copied_Code.html#ch-6-fvs",
    "href": "1_Copied_Code.html#ch-6-fvs",
    "title": "Plot Selection",
    "section": "CH 6 FVS",
    "text": "CH 6 FVS\nThis code chunk runs FVS to get CC, BA, and SDI.\nSet FVS bin to the FVS executable.\nThis time consuming step might be avoided using the p2veg_spp table. There is a canopy cover by species variable there. It could be summed. Also, perhaps using percent CC by species could be a better predictor than just CC.\nFVS has been running for 20 minutes with these 25,516 subplots.\n\nrm(list = ls())\n\nlibrary(RSQLite)\nlibrary(tidyverse, quietly = T, warn.conflicts = F)\nlibrary(readxl)\n\noptions(scipen = 999)\n\n\n# 1. Set paths ---------------------------------------------------------------\n## Set all the file paths and names in this section. Then, run the rest of the script in sections 2. \n\n## Set the working directory here.\n# setwd(\"C:\\\\RxFire\\\\Regen\\\\FVS\")\nfvs_wd &lt;- \"C:\\\\RxFire\\\\Regen\\\\FVS\"\n\n## Where are the FVS executables? FVSbin? \n#  Include the \\\\FVS prefix to variant.exe. \nFVSbin &lt;-  \"C:\\\\FVSbin_v3.1\\\\FVS\"\n\n# Test\n\nname &lt;- str_c(\"regen_\", \n              strftime(Sys.Date(),\"%m%d%y\"), \n              \"_\", \n              strftime(Sys.time(),\"%H%M\"))\n\n\n## Set the path to the stand input database here, aka the output db from 3_CNs_to_FVS:\ninputDatabase &lt;- 'C:/RxFire/Regen/Mar24_Regen_FVS.db'\n# C:\\\\RxFire\\\\Data\\\\FIADB_WA.db\n# C:\\\\RxFire\\\\Regen\\\\FVS\\\\Feb6_Regen_FVS_1.db\n# C:\\\\RxFire\\\\Regen\\\\Feb7_Regen_FVS_1.db\n\n# 1.2 Standlist from xlsx -------------------------------------------------\n\nstandlist &lt;- read_csv(\"C:/RxFire/Regen/Regen_Notes/standlist03242024.csv\", \n                      col_types = c(\"cccc\")) |&gt; select(\n                        CN = STANDPLOT_CN, FVSVariant = VARIANT\n                      ) \n\n# This is to speed up the testing\n# standlist &lt;- standlist[1:1000, ]\n\n\n\n# 2. Batch file Creation -----------------------------------------------------\n## Run everything in section 2. There shouldn't be anything to change.\n#  Except, maybe createInputFile(group_stands$CN[s], if CN was read in as Stand_CN. \n\n\nint &lt;- Sys.time()\n\n# Create directory where FVS runs will be sent:\nRunDirectory &lt;- str_c(fvs_wd, '/', name)\n\nif (!dir.exists(RunDirectory)) {\n  print(paste(\"Making Run directory: \", RunDirectory))\n  dir.create(RunDirectory)\n} else(\n  print(str_c(RunDirectory, \", already exists\"))\n)\n\n# Create input Directory\ninputDirectory &lt;- str_c(RunDirectory, \"/In\")\n\nif (!dir.exists(inputDirectory)) {\n  print(paste(\"Making input directory: \", inputDirectory))\n  dir.create(inputDirectory)\n} else(\n  print(str_c(inputDirectory, \", already exists\"))\n)\n\n# Create Cmd Directory\nCmdDirectory &lt;- str_c(RunDirectory, \"/Cmd\")\n\nif (!dir.exists(CmdDirectory)) {\n  print(paste(\"Making input directory: \", CmdDirectory))\n  dir.create(CmdDirectory)\n} else(\n  print(str_c(CmdDirectory, \", already exists\"))\n)\n\n## The path to the FVS output database is set here:\noutputDatabase &lt;- str_c(RunDirectory, \"/\", name, \".db\")\n\n\n\n## This function creates the string for a single stand in FVS.\ncreateInputFile &lt;- function(stand, managementID, inputDatabase, outputDatabase){\n  # Create .key file\n  input &lt;- paste0('STDIDENT\\n',                     \n                  stand, '\\n',                     \n                  'STANDCN\\n',                     \n                  stand, '\\n',                     \n                  'MGMTID\\n',                     \n                  managementID,                     \n                  '\\n',                             \n                  'NUMCYCLE          1\\n', # Set time intervals. \n                  # 0 = Change all cycles | Cycle length to one year\n                  'TIMEINT           0         1\\n',\n                  'SCREEN\\n',               \n                  'DATABASE\\n',                                                                                     # Databases in    \n                  'DSNIN\\n',                                                \n                  inputDatabase, '\\n',                                        \n                  'StandSQL\\n',                                             \n                  'SELECT * FROM FVS_PLOTINIT_PLOT\\n',\n                  # 'SELECT * FROM FVS_PlotInit\\n',  # For a different table name                   \n                  \"WHERE  Standplot_CN  = '%stand_cn%'\\n\",                     \n                  'EndSQL\\n',                                                    \n                  'DSNIN\\n',                                          \n                  inputDatabase, '\\n',                                             \n                  'TreeSQL\\n',\n                  'SELECT * FROM FVS_TREEINIT_PLOT\\n',\n                  # 'SELECT * FROM FVS_TreeInit\\n',                              \n                  \"WHERE  Standplot_CN  = '%stand_cn%'\\n\",                            \n                  'EndSQL\\n',                                                          \n                  'END\\n',   # Database ends here\n                  'STRCLASS\\n',\n                  # year of compute 0 = Every cycle\n                  'COMPUTE           0\\n',                                                                        # Compute below here\n                  # # acancov defined when str_class is used, after thin Canopy\n                  'CC = bcancov\\n',\n                  'END\\n',                                                                                            # Compute ends\n                  'DATABASE\\n',                                                                                     # DB Out Starts\n                  'DSNOUT\\n',                                      \n                  outputDatabase, '\\n',\n                  'SUMMARY           2\\n',\n                  'StrClsDB\\n',\n                  'COMPUTDB\\n',\n                  'END\\n',\n                  'Process\\n\\n')                                    \n                   \n  \n}\n\nwrite(str_c(\"set RScript=\", \" \\\"\", \"C:/Program Files/R/R-4.3.1/bin/Rscript.exe\", \"\\\"\",\n            \"\\n \\n\",\n            \"cd \", inputDirectory, \"\\n\\n\"), paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n\n\n\nfor (g in unique(standlist$FVSVariant)) {\n  masterkeys &lt;- NULL\n  group_stands &lt;- subset(standlist, FVSVariant == g)\n  for (s in 1:nrow(group_stands)) {\n    \n    keywords &lt;- createInputFile(stand = group_stands$CN[s], managementID = group_stands$CN[s], \n                                inputDatabase = inputDatabase,\n                                outputDatabase = outputDatabase\n                                )\n    \n    masterkeys &lt;- paste0(masterkeys, keywords)\n  }\n  # Print to the key file\n  masterkeys &lt;- paste0(masterkeys, \"\\nSTOP\\n\")\n  # \"\\n STOP?\\n\" or \"\\nSTOP\\n\", outfile has errors 1 & 2, invalid keyword & no Stop\n  file_name &lt;- str_sub(g, end = -5)\n  write(masterkeys, file = str_c(inputDirectory, '\\\\', g, '.key'))\n  \n  ## Create the .in file ##\n  fvs_in &lt;- paste0(g, \".key\\n\",\n                   g, \".fvs\\n\",\n                   g, \".out\\n\",\n                   g, \".trl\\n\",\n                   g, \".sum\\n\")\n  \n  fvs_in_file &lt;- paste0(inputDirectory, '\\\\', g, '.in')\n  write(fvs_in, file = fvs_in_file)\n  fvs_bat &lt;- paste0(FVSbin, unique(group_stands$FVSVariant), \".exe &lt; \", g, \".in &gt;\",\n                    RunDirectory, \"/Cmd/\", g, \".txt\", \" 2&gt;&1\", \"\\n\",\n                    # Send each CMD file to this script\n                    \"%RScript%\",\" C:/RxFire/Scripts/ErrorProcessing/RcmdProcess.R \",\n                    \"\\\"\", RunDirectory, \"/Cmd/\", g, \".txt\", \"\\\"\", \"\\n\")\n  \n  write(fvs_bat, paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n}\n\n# Summarize the OUT files\nfvs_errors &lt;- str_c(\"\\nREM This one cleans in extra files out and summarizes the output the Run Directory \\n\",\n                    \"%RScript%\",\" C:/RxFire/Scripts/ErrorProcessing/RfvsProcess.R \",\n                    \"\\\"\", RunDirectory, \"/In\", \"\\\"\")\n\nwrite(fvs_errors, paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n\n# write(\"PAUSE\", paste0(inputDirectory, '\\\\test.bat'), append = \"TRUE\")\n\nout &lt;- Sys.time()\n\nprint(out - int)\n\n# Run this Batch file\nshell.exec(str_c(RunDirectory, '\\\\test.bat'))"
  },
  {
    "objectID": "1_Copied_Code.html#imputation-prep",
    "href": "1_Copied_Code.html#imputation-prep",
    "title": "Plot Selection",
    "section": "Imputation Prep",
    "text": "Imputation Prep\nPull the FVS output and organize the data.\n\nlibrary(tidyverse, quietly = T)\nlibrary(esquisse)\nlibrary(yaImpute)\nlibrary(RSQLite)\nlibrary(vegan)\nlibrary(randomForest)\nlibrary(RSQLite)\n\noptions(scipen = 999)\n\nSet k for knn. Get the compute and summary tables from the fvs run. Get the tree and plots tables from fvs_ready. Also adding the cond table for troubleshooting.\n\nk = 10\n\n\n# Pulling my list of subplots with FPAGs that I used in FVS\n# \"C:\\RxFire\\Regen\\Regen_Notes\\standlist03242024.csv\"\n# getwd()\nstandlist &lt;- read_csv(\"standlist03242024.csv\", \n                      col_types = c(\"cccc\")) \n\n\n## The FVS variables DB I created earlier by running these plots in FVS\n## and extracting the first years estimates of CC, BA, & SDI\n# \"C:/RxFire/Regen/FVS/regen_020724_4n/regen_020724_4n.db\"\n# \"C:\\RxFire\\Regen\\FVS\\regen_032524_0919\\regen_032524_0919.db\"\ncon &lt;- dbConnect(\n  RSQLite::SQLite(), \"C:/RxFire/Regen/FVS/regen_032524_0919/regen_032524_0919.db\"\n  )\n\n# Compute has CC\n# Summary2 has BA and SDI\ncomp &lt;- dbGetQuery(con, \"select CaseID, StandID, CC from FVS_Compute\")\nsummary &lt;- dbGetQuery(\n  con, \n  str_c(\"select CaseID, StandID, Tpa, BA, SDI from FVS_Summary2\",\n        \" where Year = 2020\")\n  )\n\npred &lt;- left_join(comp, summary, join_by(CaseID, StandID))\n\ndbDisconnect(con)\n\n# rm(comp, summary, con)\n\n# making a list for sql\ndb_list &lt;- function(df, CN_col){\n  name &lt;- NULL\n  name &lt;- df |&gt; select({{CN_col}})\n  name &lt;- name |&gt; mutate(CN_col = str_c(\"'\", {{CN_col}}, \"'\")) \n  name &lt;- str_flatten_comma(name$CN_col)\n  # name &lt;- str_flatten_comma(name[, CN_col])\n  name\n}\nstplt_cn &lt;- db_list(df = pred, CN_col = StandID)\n\n\n# connecting to the WA state FIA db\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# collecting the trees\ntree &lt;- dbGetQuery(\n  con, \n  str_c(\"select * from FVS_TREEINIT_PLOT where STANDPLOT_CN in (\", \n        stplt_cn, \")\"))\n\n# collecting tne plots and subplots\nplot &lt;- dbGetQuery(\n  con, \n  str_c(\"select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN in (\", \n        stplt_cn, \")\"))\n\n\n# cond &lt;- dbGetQuery(\n#   con, \n#   str_c(\"select * from cond where STANDPLOT_CN in (\", \n#         stplt_cn, \")\"))\n\ndbDisconnect(con)\n\nClean the tables.\n\n# Cleaning out the NA columns\nclean_na_cols &lt;- function(df){\n  df &lt;- df[, colSums(is.na(df)) &lt; nrow(df)]\n}\n\ntree &lt;- clean_na_cols(tree)\nplot &lt;- clean_na_cols(plot)\n\n# Cleaning out the useless columns\nplot &lt;- plot |&gt; select(-c(GROUPS, STAND_ID, STANDPLOT_ID, INV_DAY, INV_MONTH, \n                          REGION, FOREST, SAM_WT, PHYSIO_REGION, STATE, COUNTY))\n\ntree &lt;- tree |&gt; select(-c(STAND_ID, STANDPLOT_ID))\n\npred &lt;- pred |&gt; select(-c(CaseID, Tpa))\n\nSeedling densities are the trees per acre for each species’ seedlings. Adding the plant symbols for seedlings.\n\n# Separating the seedlings from the rest\nseedling_densities &lt;- tree |&gt;  filter(startsWith(TREE_CN, \"S\")) |&gt; \n  group_by(STANDPLOT_CN, SPECIES) |&gt; \n  summarise(TPA = sum(TREE_COUNT))\n\n`summarise()` has grouped output by 'STANDPLOT_CN'. You can override using the\n`.groups` argument.\n\ncon &lt;- dbConnect(\n  RSQLite::SQLite(), \"C:\\\\RxFire\\\\Data\\\\_FIADB_WA.db\"\n  )\n# Pulling in the species reference table\nplants_ref &lt;- dbGetQuery(\n  con, \"select SPECIES_SYMBOL, SPCD, COMMON_NAME, W_SPGRPCD from REF_SPECIES\"\n  )\nplant_gr_ref &lt;- dbGetQuery(\n  con, \"select SPGRPCD, NAME from REF_SPECIES_GROUP\"\n  )\ndbDisconnect(con)\n\n# Cleaning it up\nplants_ref &lt;- plants_ref |&gt; rename(SPGRPCD = W_SPGRPCD, SYMBL = SPECIES_SYMBOL)\nplants_ref &lt;- left_join(plants_ref, plant_gr_ref, by = join_by(SPGRPCD))\nplants &lt;- plants_ref |&gt; select(SYMBL, SPCD)\nseedling_densities &lt;- seedling_densities |&gt; mutate(SPECIES = as.numeric(SPECIES))\n\n# Getting plant codes for seedlings\nseedling_densities &lt;- left_join(seedling_densities, plants, join_by(\"SPECIES\" == \"SPCD\"))\n# Removing an extra col. \nseedling_densities &lt;- seedling_densities |&gt; select(-c(SPECIES))\n\nWidening the table to match the st Joe example. The value of each species TPA goes into a column for that species. Each row is a standplot_cn. If there were no species of a type in that stand, a zero is entered.\n\n# Matching the St. Joe data\nseedling_response &lt;- seedling_densities |&gt; pivot_wider(names_from = SYMBL, \n                 values_from = TPA,\n                 values_fill = 0,\n                 names_glue = \"{SYMBL}_{'TD'}\")\n\n\n# Un-grouping to avoid future messages\nseedling_response &lt;- seedling_response |&gt; ungroup()\nseedling_densities &lt;- seedling_densities |&gt; ungroup()\n\n\n\n\n# replacing all NAs with zero, just in case\nnas_to_zeroes &lt;- function(df){\n  df &lt;- df |&gt; mutate_all(~replace(., is.na(.), 0))\n  df\n}\nseedling_response &lt;- nas_to_zeroes(seedling_response) \n\n# clearing out the objects\nX_predictors &lt;- NULL\nY_response &lt;- NULL\n# creating lists of subplots\nX_predictors &lt;- pred |&gt; select(STANDPLOT_CN = StandID) |&gt; unique()\nY_response &lt;- seedling_response |&gt; select(STANDPLOT_CN = STANDPLOT_CN)\n\nThere is a mismatch in dims between the predictors and response variables.\nX has about 25k rows and Y has about 13k. This is looking at all possible plots with the value computed from FVS, vs those plots with seedlings.\nIf I remove the extra 12k rows where no regeneration is occurring, that’s bad. If I don’t remove it, then I half of my data is zero.\nThe current plan is to use a couple models, one for probability of regeneration. one for regen with and one one without disturbance. From what I understand, the probability of regen model is for post disturbance. So, this is more of an ingrowth model. We need the zeroes and I don’t like that.\nThat is what I did last time, so at least the plots will be comparable.\nI think I can at least remove the subplots that are non-forested.\n\n# finding the mismatch \ntt &lt;- anti_join(X_predictors, Y_response, by = \"STANDPLOT_CN\")\n\nt &lt;- left_join(tt, tree, by = \"STANDPLOT_CN\")\n\nt2 &lt;- t |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarize(seedling_records = sum(startsWith(TREE_CN, \"s\")),\n            lt_records = sum(!startsWith(TREE_CN, \"s\")))\n\nt3 &lt;- t2 |&gt; filter(is.na(seedling_records) & is.na(lt_records)) |&gt; \n  select(STANDPLOT_CN)\n\n\nt2 &lt;- t2 |&gt; filter(!is.na(lt_records) & !is.na(seedling_records))\n\nOf those records where there is no regen, 12k at least had large trees. 1k had neither seedlings of large trees.\nI tried to find out why there were no trees on those subplots, but I couldn’t:\n# t3 &lt;- left_join(t3, plot, by = \"STANDPLOT_CN\")\n# \n# standlist &lt;- t3 |&gt; select(STAND_CN)\n# standcn &lt;- db_list(standlist, STAND_CN)\n# \n# con &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# \n# cond &lt;- dbGetQuery(\n#   con, \n#   str_c(\"select * from cond where PLT_CN in (\", \n#         standcn, \")\"))\n# \n# dbDisconnect(con)\n# \n# cond &lt;- clean_na_cols(cond)\n# \n# \n# cond_status_cd &lt;- cond |&gt; \n#   filter(COND_STATUS_CD == 1 | COND_STATUS_CD == 2 )\n# \n# # hist(cond_status_cd$OWNGRPCD)\n# \n# # Fire damage. \n# hist(cond_status_cd[cond_status_cd$DSTRBCD1 &gt; 29 & \n#                       cond_status_cd$DSTRBCD1 &lt; 40, \n#                     \"DSTRBCD1\"])\n# \n# cond_presnfcd &lt;- cond_status_cd |&gt; \n#   filter(is.na(PRESNFCD)) |&gt; clean_na_cols()\n# \n# cond_presnfcd &lt;- cond_presnfcd |&gt; \n#   select(-c(STATECD, INVYR, CN, COUNTYCD, PLOT,\n#             MAPDEN, PROP_BASIS, SLOPE, ASPECT, DSTRBYR1, DSTRBYR2, DSTRBYR3))\n# \n# # names(cond_presnfcd)\n# \n# cond_presnfcd &lt;- cond_presnfcd |&gt; \n#   select(-c(CREATED_BY, CREATED_DATE, CREATED_IN_INSTANCE, MODIFIED_BY, MODIFIED_DATE, MODIFIED_IN_INSTANCE))\n# \n# cond_presnfcd2 &lt;- cond_presnfcd[, c(1, 49:ncol(cond_presnfcd))]\n# \n# # summary(as.factor(cond_presnfcd$STUMP_CD_PNWRS))\n# \n# # hist(cond_presnfcd$BALIVE)\nThere are standplot_cns that do not have trees. I am not sure if I should count them. They might be NAs.\nLooking at an example:\n\nThe subplot table says they are all the same.\nThe Cond table doesn’t make distinctions for Subplots.\nThere are tree records in the the other three plots.\n\nI am not sure what to do. There are some codes that should be controlled for, but I cannot get rid of all of them. Some of the codes that should be controlled for were probably brought in with the cond table, I couldn’t use standplot_cn. So it pulled in every condition.\nI found this field and it could be of use:\nPHYSCLCD Physiographic class code. A code indicating the general effect of land form, topographical position, and soil on moisture available to trees.\n\nRemoving the no tree plots.\n\nx &lt;- anti_join(X_predictors, t3, by = \"STANDPLOT_CN\")\nnrow(X_predictors) - nrow(x)\n\n[1] 895\n\nX_predictors &lt;- left_join(x, X_predictors, by = \"STANDPLOT_CN\")\n\n\n# Adding the plots without regen. \nimp_response &lt;- left_join(X_predictors, seedling_response, join_by(STANDPLOT_CN))\n\n# removing the NAs\nimp_response &lt;- nas_to_zeroes(imp_response) \n# imp_data &lt;- imp_data[,1:35]\n\n# removing fields from standlist to join\nFPAG &lt;- standlist |&gt; select(STANDPLOT_CN, FPAG)\n# renaming the field\npred &lt;- pred |&gt; rename(STANDPLOT_CN = StandID)\n\npred &lt;- left_join(x, pred, by = \"STANDPLOT_CN\")\n# joining fpags to prediction list. \nimp_pred &lt;- left_join(pred, FPAG, by = \"STANDPLOT_CN\")\n\nimp_data &lt;- left_join(imp_pred, imp_response, by = \"STANDPLOT_CN\")\n\nMaking a set for the zeroes just in case.\n\nzx &lt;- Y_response |&gt; select(STANDPLOT_CN)\n# Adding the plots without regen. \nzimp_response &lt;- left_join(zx, seedling_response, join_by(STANDPLOT_CN))\n\n# removing the NAs\nzimp_response &lt;- nas_to_zeroes(zimp_response) \n\nzpred &lt;- left_join(zx, pred, by = \"STANDPLOT_CN\")\n# joining fpags to prediction list. \nzimp_pred &lt;- left_join(zpred, FPAG, by = \"STANDPLOT_CN\")\n\nzimp_data &lt;- left_join(zimp_pred, zimp_response, by = \"STANDPLOT_CN\")\n\nCleaning up the other tables\n\ntree &lt;- left_join(x, tree, by = \"STANDPLOT_CN\")\nplot &lt;- left_join(x, plot, by = \"STANDPLOT_CN\")\n\n\n# removing extra objects\nrm(con, X_predictors, Y_response, stplt_cn, t, plant_gr_ref, \n   plants, standlist, FPAG, pred)\n\n\nname &lt;- str_c(\"attempt_\", \n              strftime(Sys.Date(),\"%m%d%y\"))\n              # , \n              # \"_\"\n              # , \n              # strftime(Sys.Date(),\"%H%M\"))\n\n# con &lt;- dbConnect(RSQLite::SQLite(), str_c(\"./\", name, \".db\"))\n# dbWriteTable(con, \"imp_data\", imp_data)\n# dbWriteTable(con, \"plants_ref\", plants_ref)\n# dbWriteTable(con, \"FVS_PLOTINIT_PLOT\", plot)\n# dbWriteTable(con, \"FVS_TREEINIT_PLOT\", tree)\n# dbWriteTable(con, \"regen_only_imp_data\", zimp_data)\n# \n# dbDisconnect(con)\n\nkeep &lt;- c(\"clean_na_cols\", \"db_list\", \"nas_to_zeroes\", \"z_scores\", \"k\")\n# rm(list = ls()[!(ls() %in% keep)])"
  },
  {
    "objectID": "2_Imputation.html",
    "href": "2_Imputation.html",
    "title": "Imputation",
    "section": "",
    "text": "Pull the FVS output and organize the data.\n\nlibrary(tidyverse, quietly = T)\nlibrary(esquisse)\nlibrary(yaImpute)\nlibrary(RSQLite)\nlibrary(vegan)\nlibrary(randomForest)\nlibrary(RSQLite)\n\noptions(scipen = 999)\n\nSet k for knn. Get the compute and summary tables from the fvs run. Get the tree and plots tables from fvs_ready. Also adding the cond table for troubleshooting.\n\nk = 10\n\n\n# Pulling my list of subplots with FPAGs that I used in FVS\n# \"C:\\RxFire\\Regen\\Regen_Notes\\standlist03242024.csv\"\n# getwd()\nstandlist &lt;- read_csv(\"standlist03242024.csv\", \n                      col_types = c(\"cccc\")) \n\n\n## The FVS variables DB I created earlier by running these plots in FVS\n## and extracting the first years estimates of CC, BA, & SDI\n# \"C:/RxFire/Regen/FVS/regen_020724_4n/regen_020724_4n.db\"\n# \"C:\\RxFire\\Regen\\FVS\\regen_032524_0919\\regen_032524_0919.db\"\ncon &lt;- dbConnect(\n  RSQLite::SQLite(), \"C:/RxFire/Regen/FVS/regen_032524_0919/regen_032524_0919.db\"\n  )\n\n# Compute has CC\n# Summary2 has BA and SDI\ncomp &lt;- dbGetQuery(con, \"select CaseID, StandID, CC from FVS_Compute\")\nsummary &lt;- dbGetQuery(\n  con, \n  str_c(\"select CaseID, StandID, Tpa, BA, SDI from FVS_Summary2\",\n        \" where Year = 2020\")\n  )\n\npred &lt;- left_join(comp, summary, join_by(CaseID, StandID))\n\ndbDisconnect(con)\n\n# rm(comp, summary, con)\n\n# making a list for sql\ndb_list &lt;- function(df, CN_col){\n  name &lt;- NULL\n  name &lt;- df |&gt; select({{CN_col}})\n  name &lt;- name |&gt; mutate(CN_col = str_c(\"'\", {{CN_col}}, \"'\")) \n  name &lt;- str_flatten_comma(name$CN_col)\n  # name &lt;- str_flatten_comma(name[, CN_col])\n  name\n}\nstplt_cn &lt;- db_list(df = pred, CN_col = StandID)\n\n\n# connecting to the WA state FIA db\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# collecting the trees\ntree &lt;- dbGetQuery(\n  con, \n  str_c(\"select * from FVS_TREEINIT_PLOT where STANDPLOT_CN in (\", \n        stplt_cn, \")\"))\n\n# collecting tne plots and subplots\nplot &lt;- dbGetQuery(\n  con, \n  str_c(\"select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN in (\", \n        stplt_cn, \")\"))\n\n\n# cond &lt;- dbGetQuery(\n#   con, \n#   str_c(\"select * from cond where STANDPLOT_CN in (\", \n#         stplt_cn, \")\"))\n\ndbDisconnect(con)\n\nClean the tables.\n\n# Cleaning out the NA columns\nclean_na_cols &lt;- function(df){\n  df &lt;- df[, colSums(is.na(df)) &lt; nrow(df)]\n}\n\ntree &lt;- clean_na_cols(tree)\nplot &lt;- clean_na_cols(plot)\n\n# Cleaning out the useless columns\nplot &lt;- plot |&gt; select(-c(GROUPS, STAND_ID, STANDPLOT_ID, INV_DAY, INV_MONTH, \n                          REGION, FOREST, SAM_WT, PHYSIO_REGION, STATE, COUNTY))\n\ntree &lt;- tree |&gt; select(-c(STAND_ID, STANDPLOT_ID))\n\npred &lt;- pred |&gt; select(-c(CaseID, Tpa))\n\nSeedling densities are the trees per acre for each species’ seedlings. Adding the plant symbols for seedlings.\n\n# Separating the seedlings from the rest\nseedling_densities &lt;- tree |&gt;  filter(startsWith(TREE_CN, \"S\")) |&gt; \n  group_by(STANDPLOT_CN, SPECIES) |&gt; \n  summarise(TPA = sum(TREE_COUNT))\n\n`summarise()` has grouped output by 'STANDPLOT_CN'. You can override using the\n`.groups` argument.\n\ncon &lt;- dbConnect(\n  RSQLite::SQLite(), \"C:\\\\RxFire\\\\Data\\\\_FIADB_WA.db\"\n  )\n# Pulling in the species reference table\nplants_ref &lt;- dbGetQuery(\n  con, \"select SPECIES_SYMBOL, SPCD, COMMON_NAME, W_SPGRPCD from REF_SPECIES\"\n  )\nplant_gr_ref &lt;- dbGetQuery(\n  con, \"select SPGRPCD, NAME from REF_SPECIES_GROUP\"\n  )\ndbDisconnect(con)\n\n# Cleaning it up\nplants_ref &lt;- plants_ref |&gt; rename(SPGRPCD = W_SPGRPCD, SYMBL = SPECIES_SYMBOL)\nplants_ref &lt;- left_join(plants_ref, plant_gr_ref, by = join_by(SPGRPCD))\nplants &lt;- plants_ref |&gt; select(SYMBL, SPCD)\nseedling_densities &lt;- seedling_densities |&gt; mutate(SPECIES = as.numeric(SPECIES))\n\n# Getting plant codes for seedlings\nseedling_densities &lt;- left_join(seedling_densities, plants, join_by(\"SPECIES\" == \"SPCD\"))\n# Removing an extra col. \nseedling_densities &lt;- seedling_densities |&gt; select(-c(SPECIES))\n\nWidening the table to match the st Joe example. The value of each species TPA goes into a column for that species. Each row is a standplot_cn. If there were no species of a type in that stand, a zero is entered.\n\n# Matching the St. Joe data\nseedling_response &lt;- seedling_densities |&gt; pivot_wider(names_from = SYMBL, \n                 values_from = TPA,\n                 values_fill = 0,\n                 names_glue = \"{SYMBL}_{'TD'}\")\n\n\n# Un-grouping to avoid future messages\nseedling_response &lt;- seedling_response |&gt; ungroup()\nseedling_densities &lt;- seedling_densities |&gt; ungroup()\n\n\n\n\n# replacing all NAs with zero, just in case\nnas_to_zeroes &lt;- function(df){\n  df &lt;- df |&gt; mutate_all(~replace(., is.na(.), 0))\n  df\n}\nseedling_response &lt;- nas_to_zeroes(seedling_response) \n\n# clearing out the objects\nX_predictors &lt;- NULL\nY_response &lt;- NULL\n# creating lists of subplots\nX_predictors &lt;- pred |&gt; select(STANDPLOT_CN = StandID) |&gt; unique()\nY_response &lt;- seedling_response |&gt; select(STANDPLOT_CN = STANDPLOT_CN)\n\nThere is a mismatch in dims between the predictors and response variables.\nX has about 25k rows and Y has about 13k. This is looking at all possible plots with the value computed from FVS, vs those plots with seedlings.\nIf I remove the extra 12k rows where no regeneration is occurring, that’s bad. If I don’t remove it, then I half of my data is zero.\nThe current plan is to use a couple models, one for probability of regeneration. one for regen with and one one without disturbance. From what I understand, the probability of regen model is for post disturbance. So, this is more of an ingrowth model. We need the zeroes and I don’t like that.\nThat is what I did last time, so at least the plots will be comparable.\nI think I can at least remove the subplots that are non-forested.\n\n# finding the mismatch \ntt &lt;- anti_join(X_predictors, Y_response, by = \"STANDPLOT_CN\")\n\nt &lt;- left_join(tt, tree, by = \"STANDPLOT_CN\")\n\nt2 &lt;- t |&gt; group_by(STANDPLOT_CN) |&gt; \n  summarize(seedling_records = sum(startsWith(TREE_CN, \"s\")),\n            lt_records = sum(!startsWith(TREE_CN, \"s\")))\n\nt3 &lt;- t2 |&gt; filter(is.na(seedling_records) & is.na(lt_records)) |&gt; \n  select(STANDPLOT_CN)\n\n\nt2 &lt;- t2 |&gt; filter(!is.na(lt_records) & !is.na(seedling_records))\n\nOf those records where there is no regen, 12k at least had large trees. 1k had neither seedlings of large trees.\nI tried to find out why there were no trees on those subplots, but I couldn’t:\n# t3 &lt;- left_join(t3, plot, by = \"STANDPLOT_CN\")\n# \n# standlist &lt;- t3 |&gt; select(STAND_CN)\n# standcn &lt;- db_list(standlist, STAND_CN)\n# \n# con &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# \n# cond &lt;- dbGetQuery(\n#   con, \n#   str_c(\"select * from cond where PLT_CN in (\", \n#         standcn, \")\"))\n# \n# dbDisconnect(con)\n# \n# cond &lt;- clean_na_cols(cond)\n# \n# \n# cond_status_cd &lt;- cond |&gt; \n#   filter(COND_STATUS_CD == 1 | COND_STATUS_CD == 2 )\n# \n# # hist(cond_status_cd$OWNGRPCD)\n# \n# # Fire damage. \n# hist(cond_status_cd[cond_status_cd$DSTRBCD1 &gt; 29 & \n#                       cond_status_cd$DSTRBCD1 &lt; 40, \n#                     \"DSTRBCD1\"])\n# \n# cond_presnfcd &lt;- cond_status_cd |&gt; \n#   filter(is.na(PRESNFCD)) |&gt; clean_na_cols()\n# \n# cond_presnfcd &lt;- cond_presnfcd |&gt; \n#   select(-c(STATECD, INVYR, CN, COUNTYCD, PLOT,\n#             MAPDEN, PROP_BASIS, SLOPE, ASPECT, DSTRBYR1, DSTRBYR2, DSTRBYR3))\n# \n# # names(cond_presnfcd)\n# \n# cond_presnfcd &lt;- cond_presnfcd |&gt; \n#   select(-c(CREATED_BY, CREATED_DATE, CREATED_IN_INSTANCE, MODIFIED_BY, MODIFIED_DATE, MODIFIED_IN_INSTANCE))\n# \n# cond_presnfcd2 &lt;- cond_presnfcd[, c(1, 49:ncol(cond_presnfcd))]\n# \n# # summary(as.factor(cond_presnfcd$STUMP_CD_PNWRS))\n# \n# # hist(cond_presnfcd$BALIVE)\nThere are standplot_cns that do not have trees. I am not sure if I should count them. They might be NAs.\nLooking at an example:\n\nThe subplot table says they are all the same.\nThe Cond table doesn’t make distinctions for Subplots.\nThere are tree records in the the other three plots.\n\nI am not sure what to do. There are some codes that should be controlled for, but I cannot get rid of all of them. Some of the codes that should be controlled for were probably brought in with the cond table, I couldn’t use standplot_cn. So it pulled in every condition.\nI found this field and it could be of use:\nPHYSCLCD Physiographic class code. A code indicating the general effect of land form, topographical position, and soil on moisture available to trees.\n\nRemoving the no tree plots.\n\nx &lt;- anti_join(X_predictors, t3, by = \"STANDPLOT_CN\")\nnrow(X_predictors) - nrow(x)\n\n[1] 895\n\nX_predictors &lt;- left_join(x, X_predictors, by = \"STANDPLOT_CN\")\n\n\n# Adding the plots without regen. \nimp_response &lt;- left_join(X_predictors, seedling_response, join_by(STANDPLOT_CN))\n\n# removing the NAs\nimp_response &lt;- nas_to_zeroes(imp_response) \n# imp_data &lt;- imp_data[,1:35]\n\n# removing fields from standlist to join\nFPAG &lt;- standlist |&gt; select(STANDPLOT_CN, FPAG)\n# renaming the field\npred &lt;- pred |&gt; rename(STANDPLOT_CN = StandID)\n\npred &lt;- left_join(x, pred, by = \"STANDPLOT_CN\")\n# joining fpags to prediction list. \nimp_pred &lt;- left_join(pred, FPAG, by = \"STANDPLOT_CN\")\n\nimp_data &lt;- left_join(imp_pred, imp_response, by = \"STANDPLOT_CN\")\n\nMaking a set for the zeroes just in case.\n\nzx &lt;- Y_response |&gt; select(STANDPLOT_CN)\n# Adding the plots without regen. \nzimp_response &lt;- left_join(zx, seedling_response, join_by(STANDPLOT_CN))\n\n# removing the NAs\nzimp_response &lt;- nas_to_zeroes(zimp_response) \n\nzpred &lt;- left_join(zx, pred, by = \"STANDPLOT_CN\")\n# joining fpags to prediction list. \nzimp_pred &lt;- left_join(zpred, FPAG, by = \"STANDPLOT_CN\")\n\nzimp_data &lt;- left_join(zimp_pred, zimp_response, by = \"STANDPLOT_CN\")\n\nCleaning up the other tables\n\ntree &lt;- left_join(x, tree, by = \"STANDPLOT_CN\")\nplot &lt;- left_join(x, plot, by = \"STANDPLOT_CN\")\n\n\n# removing extra objects\nrm(con, X_predictors, Y_response, stplt_cn, t, plant_gr_ref, \n   plants, standlist, FPAG, pred)\n\n\nname &lt;- str_c(\"attempt_\", \n              strftime(Sys.Date(),\"%m%d%y\"))\n              # , \n              # \"_\"\n              # , \n              # strftime(Sys.Date(),\"%H%M\"))\n\n# con &lt;- dbConnect(RSQLite::SQLite(), str_c(\"./\", name, \".db\"))\n# dbWriteTable(con, \"imp_data\", imp_data)\n# dbWriteTable(con, \"plants_ref\", plants_ref)\n# dbWriteTable(con, \"FVS_PLOTINIT_PLOT\", plot)\n# dbWriteTable(con, \"FVS_TREEINIT_PLOT\", tree)\n# dbWriteTable(con, \"regen_only_imp_data\", zimp_data)\n# \n# dbDisconnect(con)\n\nkeep &lt;- c(\"clean_na_cols\", \"db_list\", \"nas_to_zeroes\", \"z_scores\", \"k\")\n# rm(list = ls()[!(ls() %in% keep)])"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regen_Notes",
    "section": "",
    "text": "git add .\ngit commit -m “comment”\ngit push origin main\nquarto publish gh-pages\ngit remote set-url origin https://github.com/KingBlkMouth/Regen.git\ngit remote -v"
  },
  {
    "objectID": "index.html#these-are-git-commands-that-i-need",
    "href": "index.html#these-are-git-commands-that-i-need",
    "title": "Regen_Notes",
    "section": "",
    "text": "git add .\ngit commit -m “comment”\ngit push origin main\nquarto publish gh-pages\ngit remote set-url origin https://github.com/KingBlkMouth/Regen.git\ngit remote -v"
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Regen_Notes",
    "section": "Contents",
    "text": "Contents\nThere are many absolute paths in plot selection.\n\nPlot Selection\n\nPlot selection\n\nSelect eco-regions and associated plots\n\nCh 4\n\nRemove artificial, unsampled, non-forest, and periodic plots\n\nCh 5\n\nSelect subplots from plots,\nControl for equal conditions.\nClean FPAGs.\nSelect FVS ready data from subplot list\nWrite an input FVS database and standlist.\n\nCh 6\n\nSet: run name, input database, & standlist\nRun plots in FVS to get canopy cover.\n\n\nImputation\n\n\n\n\n\n\nunordered list\n\nsub-item 1\nsub-item 2\n\nsub-sub-item 1"
  },
  {
    "objectID": "index.html#plot-selection",
    "href": "index.html#plot-selection",
    "title": "Regen_Notes",
    "section": "Plot Selection",
    "text": "Plot Selection\nPlot Selection, Starting from a set of stands clipped from the study area in Arc Pro, Pull all of the ecoregions in the study area, then pull all stands with those ecoregions from the WA fia database.\nCh4, Pull the plot and condition tables from FIA. Control for artificial regen, unsampled CNs, non-forest conditions, and periodic plot designs. Check the ecoregion codes for mistakes and unwanted codes. Remove the condition CNs that are there only to indicate a site condition.\nCh5, Pull in the subplot’s plot and condition tables. Select only those subplots that have the same conditions on the microplot and subplot. Join the sub conditions table to with those plots that have the same conditions. Select those subplots that are at least 97.5% covered by the same conditions. Remove and habitat types that are coded as admin, non-veg, or water. Manually correct any mislabeled habitat types.\nFVS Prep, Pull in the FVS_Ready tables. Create a column for FPAG. Compare some stats with Kralicek. Write the FVS_Ready and FPAG tables to a .db. Write a standlist for FVS.\nCh6, Run the standlist and the new database in FVS to get Canopy Cover."
  },
  {
    "objectID": "index.html#imputation",
    "href": "index.html#imputation",
    "title": "Regen_Notes",
    "section": "Imputation",
    "text": "Imputation"
  }
]