[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Regen_Notes",
    "section": "",
    "text": "git add .\ngit commit -m “comment”\ngit push origin main\nquarto publish gh-pages\ngit remote set-url origin https://github.com/KingBlkMouth/Regen.git\ngit remote -v"
  },
  {
    "objectID": "index.html#these-are-git-commands-that-i-need",
    "href": "index.html#these-are-git-commands-that-i-need",
    "title": "Regen_Notes",
    "section": "",
    "text": "git add .\ngit commit -m “comment”\ngit push origin main\nquarto publish gh-pages\ngit remote set-url origin https://github.com/KingBlkMouth/Regen.git\ngit remote -v"
  },
  {
    "objectID": "index.html#plot-selection",
    "href": "index.html#plot-selection",
    "title": "Regen_Notes",
    "section": "Plot Selection",
    "text": "Plot Selection\nPlot Selection, Starting from a set of stands clipped from the study area in Arc Pro, Pull all of the ecoregions in the study area, then pull all stands with those ecoregions from the WA fia database.\nCh4, Pull the plot and condition tables from FIA. Control for artificial regen, unsampled CNs, non-forest conditions, and periodic plot designs. Check the ecoregion codes for mistakes and unwanted codes. Remove the condition CNs that are there only to indicate a site condition.\nCh5, Pull in the subplot’s plot and condition tables. Select only those subplots that have the same conditions on the microplot and subplot. Join the sub conditions table to with those plots that have the same conditions. Select those subplots that are at least 97.5% covered by the same conditions. Remove and habitat types that are coded as admin, non-veg, or water. Manually correct any mislabeled habitat types.\nFVS Prep, Pull in the FVS_Ready tables. Create a column for FPAG. Compare some stats with Kralicek. Write the FVS_Ready and FPAG tables to a .db. Write a standlist for FVS.\nCh6, Run the standlist and the new database in FVS to get Canopy Cover."
  },
  {
    "objectID": "index.html#imputation",
    "href": "index.html#imputation",
    "title": "Regen_Notes",
    "section": "Imputation",
    "text": "Imputation"
  },
  {
    "objectID": "1_Copied_Code.html",
    "href": "1_Copied_Code.html",
    "title": "Plot Selection",
    "section": "",
    "text": "The following code is pulled from my last set of notes in the stated chapters. It has all been updated as of Mar 23 2024.\nTo do\nAdd selection code from AGP.\nThis is chapter 15 from my last notebook. It is mostly a re-do of plot selection. I fixed a couple of errors that I made in the first run. This code is missing the part where I selected the plots within the NSA.\nI still need to pull in the extra plots from the rest of WA. After I do that, I will add a section that selects the plots to use. Then this will be everything that needs to be done to start looking at potential regen plots in one spot."
  },
  {
    "objectID": "1_Copied_Code.html#plot-selection",
    "href": "1_Copied_Code.html#plot-selection",
    "title": "Plot Selection",
    "section": "Plot selection",
    "text": "Plot selection\n\nlibrary(tidyverse)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\nPrevious steps:\n\nI pulled the lat and long from the FIA’s WA database.\nCreated a point cloud from the coordinates table in Arc Prp.\nClipped the point cloud with POC3/OKWEN/OKWEN_shapefiles/OKWEN_AllFOAs_60km_buffer.shp\nSaved the clipped points to 60k_buffer_fiaplots.csv.\n\nIn the following code:\n\nConnect to the WA FIA .db\nSummarize the eco regions present in the foa boundary.\nlist the eco regions in the study area.\nextract all eco regions in WA that are in our study area and the FVS_Ready data.\n\n\n\nCode\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# This is the selection of plots by lat long from the okwen all foas 60k buffer. \nfoa_60_plots &lt;- read.csv(\"C:/RxFire/Regen/60k_buffer_fiaPlots.csv\")\n\n# Matching the foa cns to the table with ecoregions. \ncns &lt;- foa_60_plots |&gt; select(CN)\n\n# dbListTables(con)\n# dbListFields(con, \"FVS_PLOTINIT_PLOT\")\n\nplots &lt;- dbGetQuery(con, \"SELECT STAND_CN, STANDPLOT_CN, ECOREGION FROM FVS_PLOTINIT_PLOT\")\n\ncns$CN &lt;- as.character(cns$CN)\n\n# 45304 plots\nplots_60 &lt;- left_join(cns, plots, join_by(CN == STAND_CN))\n\n# Checking the number of NAs\nprint(\"There are this many NAs\")\n\n\n[1] \"There are this many NAs\"\n\n\nCode\nnrow(plots_60) - nrow(drop_na(plots_60))\n\n\n[1] 1436\n\n\nCode\nplots_60 &lt;- drop_na(plots_60)\n\ndbDisconnect(con)\n\n\nn_ecos &lt;- plots_60 |&gt; group_by(ECOREGION) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(desc(n))\n\n# Create a list of ecoregions in the study area. \n# The first time, I used gen_eco, that was too broad. \neco_list &lt;- n_ecos |&gt; \n  mutate(\n    gen_eco = str_sub(ECOREGION, 1, -2)\n  )\n# Pull all plots in those ecoregions. \n# nsa_plots &lt;- plots |&gt; mutate(\n#   gen_eco = str_sub(ECOREGION, 1, -2)) |&gt; \n#   filter(gen_eco %in% eco_list$gen_eco)\n\nnsa_plots &lt;- plots |&gt; mutate(\n  gen_eco = str_sub(ECOREGION, 1, -2)) |&gt; \n  filter(ECOREGION %in% eco_list$ECOREGION)\n\n# 59,800 plots w/gen_eco, 58878 w/ecoregion\n# save(nsa_plots, file = \"nsa_plots.Rdata\")\n\nrm(list = ls()[!ls() %in% c(\"nsa_plots\")])"
  },
  {
    "objectID": "1_Copied_Code.html#ch4",
    "href": "1_Copied_Code.html#ch4",
    "title": "Plot Selection",
    "section": "Ch4",
    "text": "Ch4\n\nlibrary(tidyverse, warn.conflicts = F)\nlibrary(RSQLite)\nlibrary(readxl)\nlibrary(writexl)\n\noptions(scipen = 999)\n\n# nsa_plots &lt;- read_csv(\"C:/RxFire/Regen/Species_Plot_ecotype/FIA_NSA_Nat_design_NEWWA.csv\",\n#                       col_types = c(\"c\"))\n\nload(\"./nsa_plots.Rdata\")\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# Making a list to pull from the big database'\n# This requires less RAM than loading in the database. \nstandlist &lt;- NULL\nstandlist &lt;- str_c(\"'\", nsa_plots$STAND_CN, \"'\")\nstandlist &lt;- str_flatten_comma(standlist)\n\n# Pulling the tables\nztree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE PLT_CN IN (\", standlist, \")\"))\nzplot &lt;- dbGetQuery(con, str_c(\"select * from plot WHERE CN IN (\", standlist, \")\"))\nzp2veg &lt;- dbGetQuery(con, str_c(\"select * from P2VEG_SUBPLOT_SPP WHERE PLT_CN IN (\", standlist, \")\"))\nSPGRPkey &lt;- dbGetQuery(con,\"select * from REF_SPECIES_GROUP\")\n\n\n# Removing empty fields\nzplot &lt;- zplot[, colSums(is.na(zplot)) &lt; nrow(zplot)]\n# zstand &lt;- zstand[, colSums(is.na(zstand)) &lt; nrow(zstand)]\nztree &lt;- ztree[, colSums(is.na(ztree)) &lt; nrow(ztree)]\n# ztree_init &lt;- ztree_init[, colSums(is.na(ztree_init)) &lt; nrow(ztree_init)] \nzp2veg &lt;- zp2veg[, colSums(is.na(zp2veg)) &lt; nrow(zp2veg)]\n\nzcond &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE PLT_CN IN (\", standlist, \")\"))\nzcond &lt;- zcond[, colSums(is.na(zcond)) &lt; nrow(zcond)]\n\nprint(\"the number of condition CNs in the standlist:\") \n\n[1] \"the number of condition CNs in the standlist:\"\n\ndim(zcond)\n\n[1] 19599    98\n\n# Remove artificial regeneration, keep NAs and zeros. \nzcond &lt;- zcond |&gt; filter(\n  STDORGCD == 0 | is.na(STDORGCD)\n)\nprint(\"after controlling for artificial regen\")\n\n[1] \"after controlling for artificial regen\"\n\ndim(zcond)\n\n[1] 18049    98\n\n# # Altered: remove all non-forest conditions. \n# Remove Non-Forested Conditions related to man. \n# unique(zcond$PRESNFCD)\nzcond &lt;- zcond |&gt; filter(\n  (is.na(PRESNFCD))\n)\nprint(\"after controlling for non-forest conditions\")\n\n[1] \"after controlling for non-forest conditions\"\n\ndim(zcond)\n\n[1] 11377    98\n\n# Remove unsampled plots and water\nzcond &lt;- zcond |&gt; filter(\n  COND_STATUS_CD == 1 | is.na(COND_STATUS_CD) | COND_STATUS_CD == 2\n)\n\n\n\n# Remove unsampled plots. \nzcond &lt;- zcond |&gt; filter(\n  is.na(COND_NONSAMPLE_REASN_CD)\n)\nprint(\"after controlling for unsampled and water\")\n\n[1] \"after controlling for unsampled and water\"\n\ndim(zcond)\n\n[1] 9880   98\n\n# There should also be a line for removing the periodic visits, \n# KINDCD = 0.\nzplot &lt;- zplot |&gt; filter(\n  KINDCD != 0\n)\nx &lt;- zplot |&gt; select(PLT_CN = CN, KINDCD)\ny &lt;- left_join(zcond, x, by = \"PLT_CN\")\nzcond &lt;- drop_na(y, KINDCD)\n\nprint(\"after controlling for periodic visits\")\n\n[1] \"after controlling for periodic visits\"\n\ndim(zcond)\n\n[1] 9145   99\n\nzcond &lt;- zcond |&gt; select(\n  CN, PLT_CN, CONDID, HABTYPCD = HABTYPCD1)\n\nzcond &lt;- zcond |&gt; mutate(\n  FPAG = str_remove_all(str_sub(HABTYPCD, 1, 4), \" \")\n)\n\n# NAs in FPAG\nna &lt;- zcond |&gt; filter(is.na(FPAG))\n# good needs some cleaning\ngood &lt;- zcond |&gt; filter(!is.na(FPAG))\n\ngood$PLT_CN &lt;- as.character(good$PLT_CN)\n\n# # Confirming there are no periodic plots. \n# good |&gt; group_by(PLT_CN) |&gt; \n#   summarise(len = str_width(PLT_CN)) |&gt; \n#   arrange(len)\n\n\n\nplants &lt;- read_csv(\"C:/RxFire/Regen/Species_Plot_ecotype/PLANTS.csv\",\n                   col_types = c(\"c\",\"c\",\"c\",\"c\",\"c\"))\n\nplants &lt;- plants |&gt; select(Symbol , Common_Name) |&gt; drop_na()\n# Join the Common Names to the veg list for readability\nzp2veg &lt;- left_join(zp2veg, plants, join_by(\"VEG_SPCD\" == \"Symbol\"))\n\n# Remove extra fields\nzp2veg &lt;- zp2veg |&gt; select(CN,\n  PLT_CN, VEG_SPCD, Common_Name, COVER_PCT, PLOT, SUBP, VEG_FLDSPCD, \n  UNIQUE_SP_NBR, GROWTH_HABIT_CD)\n\n\ntest &lt;- na |&gt; select(CN)\n\n\n# Looking at those NAs\nCN &lt;- NULL\nCN &lt;- str_c(\"'\", test$CN, \"'\")\nCN &lt;- str_flatten_comma(CN)\n\ntest2 &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE CN IN (\", CN, \")\"))\ntest2 &lt;- test2[, colSums(is.na(test2)) &lt; nrow(test2)]\n\ntest &lt;- test2 |&gt; select(CN, PLT_CN)\nPLT_CN &lt;- NULL\nPLT_CN &lt;- str_c(\"'\", test$PLT_CN, \"'\")\nPLT_CN &lt;- str_flatten_comma(PLT_CN)\n\n# all cns that didn't have FPAGs\ntcond &lt;- dbGetQuery(con, str_c(\"select * from COND WHERE CN IN (\", CN, \")\"))\n\n# These plots exist and have trees, but these cond.CN's do not. \n\n# ttree has zero tree records, but tttree does. The stands have trees but not on \n#  those conditions. \nttree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE CN IN (\", CN, \")\"))\ntttree &lt;- dbGetQuery(con, str_c(\"select * from TREE WHERE PLT_CN IN (\", PLT_CN, \")\"))\n\n# There are 1,319 cond's on 1,268 plots. \n# second time through, there are 276 tconds and 245 tplots. \ntplot &lt;- dbGetQuery(con, str_c(\"select * from plot WHERE CN IN (\", PLT_CN, \")\"))\n\n\nrm(CN, PLT_CN, test, test2, tcond, ttree, tttree, tplot)\nrm(ztree, zplot, zp2veg, zcond, plants, nsa_plots, na)\nrm(standlist)\n\ndbDisconnect(con)\n\ng &lt;- good |&gt; select(PLT_CN, CONDID, HABTYPCD) |&gt; unique()\n\n# write_csv(good, \"./good_plots_03242024.csv\")\n\n6092 stands to use vs 6,337 before."
  },
  {
    "objectID": "1_Copied_Code.html#ch-5",
    "href": "1_Copied_Code.html#ch-5",
    "title": "Plot Selection",
    "section": "CH 5",
    "text": "CH 5\ngood shouldn’t have the short cns. Those are periodic visits.\n\nrm(list = ls())\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n\n# This is just the csv I saved above. \ngood &lt;- read_csv(\"./good_plots_03242024.csv\",\n                 col_types = c(\"ccnc\"))\n\ngood &lt;- good |&gt; select(PLT_CN, CONDID, FPAG) |&gt; unique()\ng &lt;- good |&gt; select(PLT_CN) |&gt; unique()\n\nPLT_CN &lt;- NULL\nPLT_CN &lt;- str_c(\"'\", g$PLT_CN, \"'\")\nPLT_CN &lt;- str_flatten_comma(PLT_CN)\n\nzsubplot &lt;- dbGetQuery(con, str_c(\"select * from subplot WHERE PLT_CN IN (\", PLT_CN, \")\"))\nzsubcond &lt;- dbGetQuery(con, str_c(\"select * from subp_cond WHERE PLT_CN IN (\", PLT_CN, \")\"))\n\n\n# This is every plot and condition that we could sample. \nzsubcond &lt;- left_join(good, zsubcond, join_by(PLT_CN, CONDID))\n\nzsubplot &lt;- zsubplot[, colSums(is.na(zsubplot)) &lt; nrow(zsubplot)]\nzsubcond &lt;- zsubcond[, colSums(is.na(zsubcond)) &lt; nrow(zsubcond)]\n\n# filter for where micro and sup were the same\nzsubplot &lt;- zsubplot |&gt; filter(\n  (MICRCOND == SUBPCOND)\n)\n\n# select all plots with equal conditions and some data for fpag\nzsubkey &lt;- zsubplot |&gt; select(PLT_CN, SUBP) |&gt; unique()\nzcondkey &lt;- zsubcond |&gt; select(PLT_CN, SUBP, FPAG) |&gt; unique()\n#  drop_na()\n\n# Joing them to make a key\nzcon &lt;- left_join(zsubkey, zcondkey, join_by(PLT_CN, SUBP)) |&gt; drop_na()\n\nzsubcond &lt;- zsubcond |&gt; select(\n  PLT_CN, CONDID, FPAG, CN, INVYR, PLOT, SUBP, MICRCOND_PROP, SUBPCOND_PROP, \n  MACRCOND_PROP, NONFR_INCL_PCT_SUBP, NONFR_INCL_PCT_MACRO, CYCLE)\n\n\nunique_conds &lt;- zsubcond |&gt; \n  filter(\n    near(SUBPCOND_PROP, 1, tol = .025) & near(MICRCOND_PROP, 1, tol = .025)\n    )\n\nt &lt;- unique_conds |&gt; select(PLT_CN, SUBP, CN, FPAG)\n\nt &lt;- t |&gt; filter(\n  !startsWith(FPAG, \"A\") & !startsWith(FPAG, \"N\") & !startsWith(FPAG, \"W\")\n)\n\n# I chose CAS4 bc it was the largest group of the three options. \nt &lt;- t |&gt; mutate(\n  FPAG = ifelse(FPAG == \"PIAL\", \"CAGO\", FPAG)\n)\n\nsubs &lt;- t |&gt; rename(SUBPLOT_CN = CN)\n\nunique(t$FPAG) |&gt; sort()\n\n  [1] \"CA\"   \"CAC1\" \"CAC5\" \"CACE\" \"CAF2\" \"CAF3\" \"CAG1\" \"CAG2\" \"CAG3\" \"CAGO\"\n [11] \"CAS-\" \"CAS2\" \"CAS3\" \"CAS4\" \"CC\"   \"CCF2\" \"CCHS\" \"CCS2\" \"CCS3\" \"CD\"  \n [21] \"CD27\" \"CD61\" \"CD63\" \"CD81\" \"CDF0\" \"CDF4\" \"CDG1\" \"CDG2\" \"CDG3\" \"CDG6\"\n [31] \"CDGE\" \"CDH4\" \"CDRX\" \"CDS\"  \"CDS1\" \"CDS2\" \"CDS3\" \"CDS4\" \"CDS5\" \"CDS6\"\n [41] \"cds7\" \"CDS7\" \"CDS8\" \"CE\"   \"CE41\" \"CE54\" \"CEF1\" \"CEF2\" \"CEF3\" \"CEF4\"\n [51] \"CEFA\" \"CEFH\" \"CEFM\" \"CEG1\" \"CEG2\" \"CEG3\" \"CEM1\" \"CEM2\" \"CEM3\" \"CEN2\"\n [61] \"CERR\" \"CES\"  \"CES1\" \"CES2\" \"CES3\" \"CES4\" \"CES5\" \"CES6\" \"CF\"   \"CFF1\"\n [71] \"CFF2\" \"CFF3\" \"CFF4\" \"CFM1\" \"CFRR\" \"CFS\"  \"CFS-\" \"CFS1\" \"CFS2\" \"CFS3\"\n [81] \"CFS4\" \"CFS5\" \"CFS6\" \"CFSC\" \"CH\"   \"CH12\" \"CH21\" \"CH6-\" \"CH62\" \"CHC2\"\n [91] \"CHD1\" \"CHF\"  \"CHF0\" \"CHF1\" \"CHF2\" \"CHF3\" \"CHF4\" \"CHF5\" \"CHF6\" \"CHF9\"\n[101] \"CHFI\" \"CHFS\" \"CHM1\" \"CHMI\" \"CHS\"  \"CHS1\" \"CHS2\" \"CHS3\" \"CHS4\" \"chs5\"\n[111] \"CHS5\" \"CHS6\" \"CHS7\" \"CHS8\" \"CHS9\" \"CHSI\" \"CL\"   \"CLM4\" \"CLS2\" \"CLS3\"\n[121] \"CLS4\" \"CLS5\" \"CM\"   \"CM53\" \"CM55\" \"CMF1\" \"CMF2\" \"CMG2\" \"CMS1\" \"CMS2\"\n[131] \"CMS3\" \"CMS4\" \"CMS5\" \"CP\"   \"CPF0\" \"CPG0\" \"CPG1\" \"CPG2\" \"CPS0\" \"CPS2\"\n[141] \"CPS3\" \"CPS5\" \"CS\"   \"CS53\" \"CSF1\" \"CSF2\" \"CSF3\" \"CW\"   \"CW33\" \"CW55\"\n[151] \"CW61\" \"CWC4\" \"CWF0\" \"CWF2\" \"CWF3\" \"CWF4\" \"CWF5\" \"CWG1\" \"CWGI\" \"CWS2\"\n[161] \"CWS3\" \"CWS4\" \"CWS5\" \"CWS8\" \"HA\"   \"HAF\"  \"HAM0\" \"HAM1\" \"HAS1\" \"HAS3\"\n[171] \"HB\"   \"HBM1\" \"HBS1\" \"HC\"   \"HCD1\" \"HCS1\" \"HCS3\" \"HD\"   \"HM\"   \"HO\"  \n[181] \"HOC2\" \"HOG1\" \"HOG2\" \"HOG3\" \"HOS1\" \"HOS3\" \"HOS6\" \"HQ\"   \"HQG1\" \"HQM2\"\n[191] \"HQS0\" \"HQS2\" \"HX\"   \"SM20\" \"SM40\" \"SM81\" \"SW21\" \"SW22\" \"SW72\"\n\ndbDisconnect(con)\n\nOnly conifer hardwood and shrub classes present.\n\nFVS prep\n\ncon &lt;- dbConnect(RSQLite::SQLite(), \"C:/RxFire/Data/_FIADB_WA.db\")\n# write_csv(subs, \"./good_SUB_plots.csv\")\n\nsubs &lt;- read_csv(\"./good_SUB_plots.csv\",\n                 col_types = c(\"cncc\"))\n\nsubs &lt;- subs |&gt; mutate(\n  STANDPLOT_CN = str_c(PLT_CN, \"_\", SUBP)\n)\n\nSTAND_CN &lt;- NULL\nSTAND_CN &lt;- str_c(\"'\", subs$PLT_CN, \"'\")\nSTAND_CN &lt;- str_flatten_comma(STAND_CN)\n\nSTANDPLOT_CN &lt;- NULL\nSTANDPLOT_CN &lt;- str_c(\"'\", subs$STANDPLOT_CN, \"'\")\nSTANDPLOT_CN &lt;- str_flatten_comma(STANDPLOT_CN)\n\n\nstand &lt;- dbGetQuery(con, \n                    str_c(\"Select * from FVS_STANDINIT_PLOT where STAND_CN IN (\", STAND_CN, \")\"))\n\nplot &lt;- dbGetQuery(con, \n                   str_c(\"Select * from FVS_PLOTINIT_PLOT where STANDPLOT_CN IN (\", STANDPLOT_CN, \")\"))\n\nplot &lt;- plot[, colSums(is.na(plot)) &lt; nrow(plot)]\nstand &lt;- stand[, colSums(is.na(stand)) &lt; nrow(stand)]\n\nplot &lt;- subset(plot, select = -c(GROUPS, INV_MONTH, INV_DAY, DATUM))\n\n\nstand &lt;- subset(stand, select = -c(INV_MONTH, INV_DAY, STATE, COUNTY))\n\n\nt &lt;- plot |&gt; select(STANDPLOT_CN)\n\nt &lt;- left_join(t, subs, by = \"STANDPLOT_CN\")\n\nt &lt;- t |&gt; mutate(\n  FPAG = str_remove_all(str_to_upper(FPAG), \" \")\n)\n\nSTANDPLOT_CN &lt;- NULL\nSTANDPLOT_CN &lt;- str_c(\"'\", t$STANDPLOT_CN, \"'\")\nSTANDPLOT_CN &lt;- str_flatten_comma(STANDPLOT_CN)\n\ntree &lt;- dbGetQuery(con, \n                   str_c(\"Select * from FVS_TREEINIT_PLOT where STANDPLOT_CN IN (\", STANDPLOT_CN, \")\"))\n\ntree &lt;- tree[, colSums(is.na(tree)) &lt; nrow(tree)]\n\n\n# 8701 records\nregen &lt;- tree |&gt; filter(\n  startsWith(TREE_CN, \"S\")\n) |&gt; select(STANDPLOT_CN) |&gt; unique()\n\n\nsubs &lt;- subs[, c(1, 2, 4, 5)]\n\nregen &lt;- left_join(regen, subs, by = \"STANDPLOT_CN\")\n\nrtrees &lt;- left_join(regen, tree, by = \"STANDPLOT_CN\")\n\nt4 &lt;- regen |&gt; group_by(FPAG) |&gt; summarise(n = n()) \n\nprint(\"Median number of subplots where regen occurred is \")\n\n[1] \"Median number of subplots where regen occurred is \"\n\nmedian(t4$n)\n\n[1] 8\n\ns &lt;- subs |&gt; select(STANDPLOT_CN, FPAG)\np &lt;- left_join(plot, s, by = \"STANDPLOT_CN\")\n\np$INV_YEAR &lt;-  2020\n\n\nrm(t, t4)\ndbDisconnect(con)\n \n# con = dbConnect(RSQLite::SQLite(), dbname = 'C:/RxFire/Regen/Mar24_Regen_FVS.db')\n# \n# dbWriteTable(conn = con, name = \"FVS_STANDINIT_PLOT\", value = stand, overwrite = T)\n# dbWriteTable(conn = con, name = \"FVS_PLOTINIT_PLOT\", value = p, overwrite = T)\n# dbWriteTable(conn = con, name = \"FVS_TREEINIT_PLOT\", value = tree, overwrite = T)\n# dbListTables(conn = con)\n# dbDisconnect(con)\n\nstandlist &lt;- p |&gt; select(STAND_CN, STANDPLOT_CN, VARIANT, FPAG)\n\nunique(standlist$VARIANT)\n\n[1] \"EC\" \"WC\" \"PN\" \"IE\"\n\nstandlist &lt;- standlist |&gt; mutate(\n  VARIANT = ifelse(VARIANT == \"PN\", \"WC\", VARIANT),\n  VARIANT = ifelse(VARIANT == \"IE\", \"EC\", VARIANT)\n)\nunique(standlist$VARIANT)\n\n[1] \"EC\" \"WC\"\n\n# write_csv(standlist, \"./standlist03242024.csv\")"
  },
  {
    "objectID": "1_Copied_Code.html#ch-6-fvs",
    "href": "1_Copied_Code.html#ch-6-fvs",
    "title": "Plot Selection",
    "section": "CH 6 FVS",
    "text": "CH 6 FVS\nThis code chunk runs FVS to get CC.\n\nrm(list = ls())\n\nlibrary(RSQLite)\nlibrary(tidyverse, quietly = T, warn.conflicts = F)\nlibrary(readxl)\n\noptions(scipen = 999)\n\n\n# 1. Set paths ---------------------------------------------------------------\n## Set all the file paths and names in this section. Then, run the rest of the script in sections 2. \n\n## Set the working directory here.\nsetwd(\"C:\\\\RxFire\\\\Regen\\\\FVS\")\n\n## Where are the FVS executables? FVSbin? \n#  Include the \\\\FVS prefix to variant.exe. \nFVSbin &lt;-  \"C:\\\\FVSbin_v3.1\\\\FVS\"\n\n# \n## Name this Run\nname &lt;- \"regen_03242024_1\"\n\n\n## Set the path to the stand input database here, aka the output db from 3_CNs_to_FVS:\ninputDatabase &lt;- 'C:/RxFire/Regen/Mar24_Regen_FVS.db'\n# C:\\\\RxFire\\\\Data\\\\FIADB_WA.db\n# C:\\\\RxFire\\\\Regen\\\\FVS\\\\Feb6_Regen_FVS_1.db\n# C:\\\\RxFire\\\\Regen\\\\Feb7_Regen_FVS_1.db\n\n# 1.2 Standlist from xlsx -------------------------------------------------\n\nstandlist &lt;- read_csv(\"C:/RxFire/Regen/Regen_Notes/standlist03242024.csv\", \n                      col_types = c(\"cccc\")) |&gt; select(\n                        CN = STANDPLOT_CN, FVSVariant = VARIANT\n                      ) \n\n# This is to speed up the testing\n# standlist &lt;- standlist[1:1000, ]\n\n\n\n# 2. Batch file Creation -----------------------------------------------------\n## Run everything in section 2. There shouldn't be anything to change.\n#  Except, maybe createInputFile(group_stands$CN[s], if CN was read in as Stand_CN. \n\n\nint &lt;- Sys.time()\n\n# Create directory where FVS runs will be sent:\nRunDirectory &lt;- str_c(getwd(), '/', name)\n\nif (!dir.exists(RunDirectory)) {\n  print(paste(\"Making Run directory: \", RunDirectory))\n  dir.create(RunDirectory)\n} else(\n  print(str_c(RunDirectory, \", already exists\"))\n)\n\n# Create input Directory\ninputDirectory &lt;- str_c(RunDirectory, \"/In\")\n\nif (!dir.exists(inputDirectory)) {\n  print(paste(\"Making input directory: \", inputDirectory))\n  dir.create(inputDirectory)\n} else(\n  print(str_c(inputDirectory, \", already exists\"))\n)\n\n# Create Cmd Directory\nCmdDirectory &lt;- str_c(RunDirectory, \"/Cmd\")\n\nif (!dir.exists(CmdDirectory)) {\n  print(paste(\"Making input directory: \", CmdDirectory))\n  dir.create(CmdDirectory)\n} else(\n  print(str_c(CmdDirectory, \", already exists\"))\n)\n\n## The path to the FVS output database is set here:\noutputDatabase &lt;- str_c(RunDirectory, \"/\", name, \".db\")\n\n\n\n## This function creates the string for a single stand in FVS.\ncreateInputFile &lt;- function(stand, managementID, inputDatabase, outputDatabase, areaSpecificKcp, FL){\n  # Create .key file\n  input &lt;- paste0('STDIDENT\\n',                     \n                  stand, '\\n',                     \n                  'STANDCN\\n',                     \n                  stand, '\\n',                     \n                  'MGMTID\\n',                     \n                  managementID,                     \n                  '\\n',                             \n                  'NUMCYCLE          1\\n', # Set time intervals. \n                  # 0 = Change all cycles | Cycle length to one year\n                  'TIMEINT           0         1\\n',\n                  'SCREEN\\n',               \n                  'DATABASE\\n',                                                                                     # Databases in       \n                  'DSNIN\\n',                                                \n                  inputDatabase, '\\n',                                        \n                  'StandSQL\\n',                                             \n                  'SELECT * FROM FVS_PLOTINIT_PLOT\\n',\n                  # 'SELECT * FROM FVS_PlotInit\\n',  # For a different spelling                   \n                  \"WHERE  Standplot_CN  = '%stand_cn%'\\n\",                     \n                  'EndSQL\\n',                                                    \n                  'DSNIN\\n',                                          \n                  inputDatabase, '\\n',                                             \n                  'TreeSQL\\n',\n                  'SELECT * FROM FVS_TREEINIT_PLOT\\n',\n                  # 'SELECT * FROM FVS_TreeInit\\n',                              \n                  \"WHERE  Standplot_CN  = '%stand_cn%'\\n\",                            \n                  'EndSQL\\n',                                                          \n                  'END\\n',   # Database ends here\n                  'STRCLASS\\n',\n                  # year of compute 0 = Every cycle\n                  'COMPUTE           0\\n',                                                                        # Compute below here\n                  # # acancov defined when str_class is used, after thin Canopy\n                  'CC = bcancov\\n',\n                  'END\\n',                                                                                            # Compute ends\n                  'DATABASE\\n',                                                                                     # DB Out Starts\n                  'DSNOUT\\n',                                      \n                  outputDatabase, '\\n',\n                  'SUMMARY           2\\n',\n                  'StrClsDB\\n',\n                  'COMPUTDB\\n',\n                  'END\\n',\n                  'Process\\n\\n')                                    \n                   \n  \n}\n\nwrite(str_c(\"set RScript=\", \" \\\"\", \"C:/Program Files/R/R-4.3.1/bin/Rscript.exe\", \"\\\"\",\n            \"\\n \\n\",\n            \"cd \", inputDirectory, \"\\n\\n\"), paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n\n\n\nfor (g in unique(standlist$FVSVariant)) {\n  masterkeys &lt;- NULL\n  group_stands &lt;- subset(standlist, FVSVariant == g)\n  for (s in 1:nrow(group_stands)) {\n    \n    keywords &lt;- createInputFile(stand = group_stands$CN[s], managementID = group_stands$CN[s], \n                                inputDatabase = inputDatabase,\n                                outputDatabase = outputDatabase, \n                                areaSpecificKcp = (paste0(kcp_dir, \"/\", group_stands$kcp[s])), \n                                FL = FL[a])\n    \n    masterkeys &lt;- paste0(masterkeys, keywords)\n  }\n  # Print to the key file\n  masterkeys &lt;- paste0(masterkeys, \"\\nSTOP\\n\")\n  # \"\\n STOP?\\n\" or \"\\nSTOP\\n\", outfile has errors 1 & 2, invalid keyword & no Stop\n  file_name &lt;- str_sub(g, end = -5)\n  write(masterkeys, file = str_c(inputDirectory, '\\\\', g, '.key'))\n  \n  ## Create the .in file ##\n  fvs_in &lt;- paste0(g, \".key\\n\",\n                   g, \".fvs\\n\",\n                   g, \".out\\n\",\n                   g, \".trl\\n\",\n                   g, \".sum\\n\")\n  \n  fvs_in_file &lt;- paste0(inputDirectory, '\\\\', g, '.in')\n  write(fvs_in, file = fvs_in_file)\n  fvs_bat &lt;- paste0(FVSbin, unique(group_stands$FVSVariant), \".exe &lt; \", g, \".in &gt;\",\n                    RunDirectory, \"/Cmd/\", g, \".txt\", \" 2&gt;&1\", \"\\n\",\n                    # Send each CMD file to this script\n                    \"%RScript%\",\" C:/RxFire/Scripts/ErrorProcessing/RcmdProcess.R \",\n                    \"\\\"\", RunDirectory, \"/Cmd/\", g, \".txt\", \"\\\"\", \"\\n\")\n  \n  write(fvs_bat, paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n}\n\n# Summarize the OUT files\nfvs_errors &lt;- str_c(\"\\nREM This one cleans in extra files out and summarizes the output the Run Directory \\n\",\n                    \"%RScript%\",\" C:/RxFire/Scripts/ErrorProcessing/RfvsProcess.R \",\n                    \"\\\"\", RunDirectory, \"/In\", \"\\\"\")\n\nwrite(fvs_errors, paste0(RunDirectory, '\\\\test.bat'), append = \"TRUE\")\n\n# write(\"PAUSE\", paste0(inputDirectory, '\\\\test.bat'), append = \"TRUE\")\n\nout &lt;- Sys.time()\n\nprint(out - int)\n\n# Run this Batch file\nshell.exec(str_c(RunDirectory, '\\\\test.bat'))"
  },
  {
    "objectID": "2_Imputation.html",
    "href": "2_Imputation.html",
    "title": "Imputation",
    "section": "",
    "text": "Pull the FVS output and organize the data."
  }
]